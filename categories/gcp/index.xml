<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Content and Tooling â€“ gcp</title><link>https://puppetlabs.github.io/content-and-tooling-team/categories/gcp/</link><description>Recent content in gcp on Content and Tooling</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 05 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://puppetlabs.github.io/content-and-tooling-team/categories/gcp/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog: Collecting GCP info and system metrics for Honeycomb</title><link>https://puppetlabs.github.io/content-and-tooling-team/blog/posts/2020-10-05-honeycomb-gcp-metrics/</link><pubDate>Mon, 05 Oct 2020 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/blog/posts/2020-10-05-honeycomb-gcp-metrics/</guid><description>
&lt;p>For a new and exciting project, the team is currently onboarding on &lt;a href="https://en.wikipedia.org/wiki/Google_Cloud_Platform">Google Cloud Platform (GCP)&lt;/a> development.&lt;/p>
&lt;!-- This is part of a series of posts describing our journey. -->
&lt;p>I can&amp;rsquo;t wait until I&amp;rsquo;m able to share more, but for now I can only say we&amp;rsquo;re looking at a &lt;a href="http://sinatrarb.com/intro.html">Sinatra&lt;/a>-hosted Ruby API server.
To gain a better understanding how the service is performing, we want to collect some &amp;ldquo;traditional&amp;rdquo; metrics.
Since we&amp;rsquo;re already using honeycomb for tracing &lt;a href="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-teamblog/updates/2020-03-30-debugging-unit-tests-with-honeycomb.md">tests&lt;/a> and &lt;a href="https://docs.honeycomb.io/getting-data-in/ruby/beeline/#sinatra">API calls&lt;/a>, looking into honeycomb for more was my first choice.
Most of the content here is based off the &amp;ldquo;Getting Started With Honeycomb Metrics&amp;rdquo; whitepaper at [https://www.honeycomb.io/white-papers/], made specific to Ruby and GCP.&lt;/p>
&lt;h2 id="static-runtime-information">Static runtime information&lt;/h2>
&lt;p>The first thing to collect is some static information about the container runtime hosting the current process.
We&amp;rsquo;re using &lt;a href="https://cloud.google.com/run/docs">Cloud Run&lt;/a> as our primary deployment infrastructure for the API services, so this is our first stop.
The &lt;a href="https://cloud.google.com/compute/docs/storing-retrieving-metadata">metadata server&lt;/a> provides details about the container instance as described in &amp;ldquo;&lt;a href="https://cloud.google.com/run/docs/reference/container-contract#metadata-server">Container instance metadata server&lt;/a>&amp;rdquo;.&lt;/p>
&lt;p>The GCP ruby gems provide &lt;code>Google::Cloud.env&lt;/code> to access the metadata server.
Here is a pruned example of how to add metadata to all spans for easy filtering:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#8be9fd;font-style:italic">require&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;honeycomb-beeline&amp;#39;&lt;/span>
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>configure &lt;span style="color:#ff79c6">do&lt;/span> &lt;span style="color:#ff79c6">|&lt;/span>config&lt;span style="color:#ff79c6">|&lt;/span>
config&lt;span style="color:#ff79c6">.&lt;/span>service_name &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;backend&amp;#39;&lt;/span>
&lt;span style="color:#ff79c6">end&lt;/span>
env &lt;span style="color:#ff79c6">=&lt;/span> Google&lt;span style="color:#ff79c6">::&lt;/span>Cloud&lt;span style="color:#ff79c6">.&lt;/span>env
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_field(&lt;span style="color:#f1fa8c">&amp;#39;gcp.project_id&amp;#39;&lt;/span>, env&lt;span style="color:#ff79c6">.&lt;/span>project_id)
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_field(&lt;span style="color:#f1fa8c">&amp;#39;gcp.instance_id&amp;#39;&lt;/span>, env&lt;span style="color:#ff79c6">.&lt;/span>lookup_metadata(&lt;span style="color:#f1fa8c">&amp;#39;instance&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;id&amp;#39;&lt;/span>))
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_field(&lt;span style="color:#f1fa8c">&amp;#39;gcp.instance_name&amp;#39;&lt;/span>, env&lt;span style="color:#ff79c6">.&lt;/span>instance_name)
region_result &lt;span style="color:#ff79c6">=&lt;/span> env&lt;span style="color:#ff79c6">.&lt;/span>lookup_metadata &lt;span style="color:#f1fa8c">&amp;#34;instance&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;region&amp;#34;&lt;/span>
region &lt;span style="color:#ff79c6">=&lt;/span> region_result&lt;span style="color:#ff79c6">&amp;amp;.&lt;/span>split(&lt;span style="color:#f1fa8c">&amp;#39;/&amp;#39;&lt;/span>)&lt;span style="color:#ff79c6">&amp;amp;.&lt;/span>last
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_field(&lt;span style="color:#f1fa8c">&amp;#39;gcp.instance_region&amp;#39;&lt;/span>, region)
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_field(&lt;span style="color:#f1fa8c">&amp;#39;gcp.instance_zone&amp;#39;&lt;/span>, env&lt;span style="color:#ff79c6">.&lt;/span>instance_zone)
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_field(&lt;span style="color:#f1fa8c">&amp;#39;gcp.instance_machine_type&amp;#39;&lt;/span>, env&lt;span style="color:#ff79c6">.&lt;/span>instance_machine_type)
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_field(&lt;span style="color:#f1fa8c">&amp;#39;gcp.instance_blog_tags&amp;#39;&lt;/span>, env&lt;span style="color:#ff79c6">.&lt;/span>instance_blog_tags)
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_field(&lt;span style="color:#f1fa8c">&amp;#39;gcp.knative_service_id&amp;#39;&lt;/span>, env&lt;span style="color:#ff79c6">.&lt;/span>knative_service_id)
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_field(&lt;span style="color:#f1fa8c">&amp;#39;gcp.knative_service_revision&amp;#39;&lt;/span>, env&lt;span style="color:#ff79c6">.&lt;/span>knative_service_revision)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Put this code somewhere that is loaded on app start up.
For rack-based frameworks like sinatra this is the &lt;code>config.ru&lt;/code>, where we include this code through &lt;code>require&lt;/code>.&lt;/p>
&lt;p>At the same time, we can also add private configuration flags from our service, to track their influence.
For example, to capture whether &lt;code>FLAG_ENABLED&lt;/code> has been set in the container&amp;rsquo;s variables:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_field(&lt;span style="color:#f1fa8c">&amp;#39;flag_enabled&amp;#39;&lt;/span>, ENV&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;FLAG_ENABLED&amp;#39;&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;true&amp;#39;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The attributes show up in the trace/span sidebar and can be used in any query:&lt;/p>
&lt;p>&lt;img src="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-team/assets/2020-10-05-honeycomb-gcp-metrics/gcp_attributes.png" alt="">&lt;/p>
&lt;h2 id="dynamic-data">Dynamic Data&lt;/h2>
&lt;p>For the actual system metrics, like CPU and memory usage, &lt;a href="https://github.com/honeycombio/libhoney-rb">libhoney&lt;/a> offers builders and &lt;a href="https://docs.honeycomb.io/getting-data-in/ruby/sdk/#advanced-usage-dynamic-fields">dynamic fields&lt;/a> (&lt;a href="https://www.rubydoc.info/gems/libhoney/Libhoney%2FClient:add_dynamic_field">API docs&lt;/a>).
Dynamic fields get evaluated at the start of each span[&lt;a href="https://github.com/honeycombio/beeline-ruby/blob/15341f01740001acbc1f2748e68cbe380bfc3f7f/lib/honeycomb/span.rb#L31">1&lt;/a>] and added to the fields sent to Honeycomb.&lt;/p>
&lt;p>To access the current &lt;a href="http://en.wikipedia.org/wiki/Resident_set_size">Resident Set Size&lt;/a> (RSS, &amp;ldquo;memory in use&amp;rdquo;) we use the &lt;a href="https://github.com/schneems/get_process_mem">get_process_mem gem&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#8be9fd;font-style:italic">require&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;get_process_mem&amp;#39;&lt;/span>
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_dynamic_field(&lt;span style="color:#f1fa8c">&amp;#39;global.memory_inuse_bytes&amp;#39;&lt;/span>, &lt;span style="color:#8be9fd;font-style:italic">proc&lt;/span> { GetProcessMem&lt;span style="color:#ff79c6">.&lt;/span>new&lt;span style="color:#ff79c6">.&lt;/span>bytes&lt;span style="color:#ff79c6">.&lt;/span>to_i })
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The total lifetime of the process can be calculated as the difference from the start time to now:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">start &lt;span style="color:#ff79c6">=&lt;/span> Time&lt;span style="color:#ff79c6">.&lt;/span>now
Honeycomb&lt;span style="color:#ff79c6">.&lt;/span>client&lt;span style="color:#ff79c6">.&lt;/span>libhoney&lt;span style="color:#ff79c6">.&lt;/span>add_dynamic_field(&lt;span style="color:#f1fa8c">&amp;#39;global.process_uptime_seconds&amp;#39;&lt;/span>, &lt;span style="color:#8be9fd;font-style:italic">proc&lt;/span> { Time&lt;span style="color:#ff79c6">.&lt;/span>now &lt;span style="color:#ff79c6">-&lt;/span> start }
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After a few minutes of the heartbeat API call:&lt;/p>
&lt;p>&lt;img src="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-team/assets/2020-10-05-honeycomb-gcp-metrics/first_results.png" alt="">&lt;/p>
&lt;h2 id="closing-notes">Closing Notes&lt;/h2>
&lt;p>This post was written while implementing the first stab at collecting metrics.
As we continue to improve our understanding of the capabilities and limitations of GCP, I expect we will have to revisit the exact metrics collected.
For example, data written to disk in Cloud Run is stored in RAM and also counted against the service&amp;rsquo;s quota.
This sounds like something to keep an eye on eventually.&lt;/p>
&lt;p>Honeycomb recommends keeping system metrics in a separate dataset from application events.
During development we currently have very little traffic on the service, so for simplicities sake, we keep everything global and attached to all events.
We&amp;rsquo;ll have to revisit this once we get more traffic on the service.&lt;/p></description></item></channel></rss>