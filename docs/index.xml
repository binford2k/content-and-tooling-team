<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Content and Tooling – Docs</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/</link><description>Recent content in Docs on Content and Tooling</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://puppetlabs.github.io/content-and-tooling-team/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: About Litmus</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/about/</guid><description>
&lt;p>Litmus is a command line tool that allows you to run acceptance tests against Puppet modules for a variety of OSes and deployment scenarios.&lt;/p>
&lt;p>Litmus is installed as (experimental) part of the &lt;a href="https://puppet.com/try-puppet/puppet-development-kit/">Puppet Development Kit&lt;/a>.&lt;/p>
&lt;ul>
&lt;li>Start with &lt;a href="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-team/docs/litmus/usage/testing/running-acceptance-tests/">running acceptance tests with Litmus&lt;/a>. This example that walks you through running an acceptance test on a module that already has Litmus tests.&lt;/li>
&lt;li>Follow the &lt;a href="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-team/docs/litmus/usage/converting-modules-to-use-litmus/">Converting modules to use Litmus&lt;/a> to enable Litmus on your module.&lt;/li>
&lt;li>&lt;a href="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-team/docs/litmus/usage/commands/litmus-core-commands/">Litmus core commands&lt;/a> has a list of what else you can do with it.&lt;/li>
&lt;li>&lt;a href="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-team/docs/litmus/litmus-concepts/">Litmus Concepts&lt;/a> explains the concepts, parts and their connection inside litmus.&lt;/li>
&lt;/ul>
&lt;p>Other pages on this site:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-team/docs/litmus/usage/tools-included-in-litmus/">Tools included in Litmus&lt;/a>. An overview of the tools Litmus uses.&lt;/li>
&lt;li>&lt;a href="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-team/docs/litmus/usage/testing/litmus-test-examples/">Test examples&lt;/a>. Common examples you can use in your tests.&lt;/li>
&lt;li>&lt;a href="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-team/docs/litmus/usage/litmus-helper-functions/">Helper functions&lt;/a>. A list of the helper functions that you can use in your tests.&lt;/li>
&lt;li>&lt;a href="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-team/docs/litmus/usage/commands/command-reference/">Command reference&lt;/a>. Including useful Docker commands.&lt;/li>
&lt;/ul></description></item><item><title>Docs: Quick Start Guide</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/converting-modules-to-use-litmus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/converting-modules-to-use-litmus/</guid><description>
&lt;p>The following example walks you through enabling Litmus testing in a module.&lt;/p>
&lt;p>The process involves editing or adding code to the following files:&lt;/p>
&lt;ol>
&lt;li>The &lt;code>Gemfile&lt;/code>&lt;/li>
&lt;li>The &lt;code>Rakefile&lt;/code>&lt;/li>
&lt;li>The&lt;code>.fixtures.yml&lt;/code> file&lt;/li>
&lt;li>The &lt;code>spec_helper_acceptance.rb&lt;/code> file&lt;/li>
&lt;li>The &lt;code>spec_helper_acceptance_local.rb&lt;/code> file&lt;/li>
&lt;/ol>
&lt;h2 id="before-you-begin">Before you begin&lt;/h2>
&lt;p>This guide assumes your module is compatible with &lt;a href="https://puppet.com/docs/pdk/1.x/pdk.html">Puppet Development Kit (PDK)&lt;/a>,
meaning it was either created with &lt;code>pdk new module&lt;/code> or has been converted to use PDK using the &lt;code>pdk convert&lt;/code> command.
To verify that your module is compatible with PDK, look in the modules &lt;code>metadata.json&lt;/code> file and see whether there is an entry that states the PDK version.
It will look something like &lt;code>&amp;quot;pdk-version&amp;quot;: &amp;quot;1.18.0&amp;quot;&lt;/code>.
The PDK ships litmus as an experimental component.&lt;/p>
&lt;p>To enable it, follow the steps below.&lt;/p>
&lt;h2 id="1-add-required-development-dependencies">1. Add required development dependencies&lt;/h2>
&lt;p>Inside the root directory of your module, add the following entries to the &lt;code>.fixtures.yml&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">---
&lt;span style="color:#ff79c6">fixtures&lt;/span>:
&lt;span style="color:#ff79c6">repositories&lt;/span>:
&lt;span style="color:#ff79c6">facts&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#39;https://github.com/puppetlabs/puppetlabs-facts.git&amp;#39;&lt;/span>
&lt;span style="color:#ff79c6">puppet_agent&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#39;https://github.com/puppetlabs/puppetlabs-puppet_agent.git&amp;#39;&lt;/span>
&lt;span style="color:#ff79c6">provision&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#39;https://github.com/puppetlabs/provision.git&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-create-the-specspec_helper_acceptancerb-file">2. Create the &lt;code>spec/spec_helper_acceptance.rb&lt;/code> file&lt;/h2>
&lt;p>Inside the &lt;code>spec&lt;/code> folder of the module, create a &lt;code>spec_helper_acceptance.rb&lt;/code> file with the following contents:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#6272a4"># frozen_string_literal: true&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">require&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;puppet_litmus&amp;#39;&lt;/span>
PuppetLitmus&lt;span style="color:#ff79c6">.&lt;/span>configure!
&lt;span style="color:#8be9fd;font-style:italic">require&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;spec_helper_acceptance_local&amp;#39;&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> File&lt;span style="color:#ff79c6">.&lt;/span>file?(File&lt;span style="color:#ff79c6">.&lt;/span>join(File&lt;span style="color:#ff79c6">.&lt;/span>dirname(__FILE__), &lt;span style="color:#f1fa8c">&amp;#39;spec_helper_acceptance_local.rb&amp;#39;&lt;/span>))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This file will later become managed by the PDK. For local changes, see the next step.&lt;/p>
&lt;h2 id="3-create-the-specspec_helper_acceptance_localrb-file">3. Create the &lt;code>spec/spec_helper_acceptance_local.rb&lt;/code> file&lt;/h2>
&lt;p>&lt;em>&lt;strong>Optional:&lt;/strong>&lt;/em> For module-specific methods to be used during acceptance testing, create a &lt;code>spec/spec_helper_acceptance_local.rb&lt;/code> file. This will be loaded at the start of each test run. If you need to use any of the Litmus methods in this file, include Litmus as a singleton class:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#6272a4"># frozen_string_literal: true&lt;/span>
&lt;span style="color:#8be9fd;font-style:italic">require&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;singleton&amp;#39;&lt;/span>
&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Helper&lt;/span>
&lt;span style="color:#ff79c6">include&lt;/span> Singleton
&lt;span style="color:#ff79c6">include&lt;/span> PuppetLitmus
&lt;span style="color:#ff79c6">end&lt;/span>
&lt;span style="color:#ff79c6">def&lt;/span> &lt;span style="color:#50fa7b">some_helper_method&lt;/span>
Helper&lt;span style="color:#ff79c6">.&lt;/span>instance&lt;span style="color:#ff79c6">.&lt;/span>bolt_run_script(&lt;span style="color:#f1fa8c">&amp;#39;path/to/file&amp;#39;&lt;/span>)
&lt;span style="color:#ff79c6">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-add-tests-to-specacceptance">4. Add tests to &lt;code>spec/acceptance&lt;/code>&lt;/h2>
&lt;p>You can find &lt;a href="https://puppetlabs.github.io/content-and-tooling-team/content-and-tooling-team/docs/litmus/usage/testing/litmus-test-examples/">litmus test examples&lt;/a> on their own page.&lt;/p></description></item><item><title>Docs: Getting Started With Templates</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/usage/templates-getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/usage/templates-getting-started/</guid><description>
&lt;p>The &lt;code>$INSTALLATION_ROOT/templates&lt;/code> directory will be subsequently referred to as the &lt;strong>Default Template Location&lt;/strong>.&lt;/p>
&lt;p>Templates currently come in 2 flavours: &lt;code>project&lt;/code> and &lt;code>item&lt;/code>.&lt;/p>
&lt;ul>
&lt;li>A &lt;code>project&lt;/code> is a template containing many files in a particular structure. They create a ready-to-run structure to start using a Puppet product. &lt;em>These are great starting points.&lt;/em> You can create a boilerplate empty starter Puppet Module or a fully customized Puppet Module with specialized CI files and RSAPI providers.&lt;/li>
&lt;li>An &lt;code>item&lt;/code> is a template that will supplement a project or existing content. These could be language features like a Puppet class or single files like a Git ignore file.&lt;/li>
&lt;/ul>
&lt;h3 id="pct-new">pct new&lt;/h3>
&lt;p>PCT is available through the &lt;code>pct new&lt;/code> command.&lt;/p>
&lt;p>The &lt;code>--list&lt;/code> or &lt;code>-l&lt;/code> flag displays a list of locally available templates located in the &lt;strong>Default Template Location&lt;/strong>. The list of templates is also available by calling &lt;code>pct new&lt;/code> without flags.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pct new
pct new --list
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Example output:&lt;/p>
&lt;!-- This breaks glamour for some reason -->
&lt;pre>&lt;code>DISPLAYNAME | AUTHOR | NAME | TYPE
──────────────────────────────┼────────────┼─────────────────────────┼─────────
Bolt Plan | puppetlabs | bolt-plan | item
Bolt Project | puppetlabs | bolt-project | project
Bolt PowerShell Task | puppetlabs | bolt-pwsh-task | item
Bolt YAML Plan | puppetlabs | bolt-yaml-plan | item
Puppet Module Managed Gemfile | puppetlabs | git-attributes | item
Puppet Class | puppetlabs | puppet-class | item
Puppet Content Template | puppetlabs | puppet-content-template | project
Puppet Defined Type | puppetlabs | puppet-defined-type | item
Puppet Fact | puppetlabs | puppet-fact | item
Puppet Module | puppetlabs | puppet-module | project
Puppet Resource API Provider | puppetlabs | rsapi-provider | item
Puppet Resource API Transport | puppetlabs | puppet-transport | item
&lt;/code>&lt;/pre>
&lt;p>Using the available templates above, its time to generate some content.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pct new &amp;lt;author&amp;gt;/&amp;lt;template&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Replace &lt;code>&amp;lt;author&amp;gt;&lt;/code> and &lt;code>&amp;lt;template&amp;gt;&lt;/code> with the &lt;code>author&lt;/code> and &lt;code>name&lt;/code> of the template containing the content you want.&lt;/p>
&lt;p>By default the &lt;code>new &amp;lt;author&amp;gt;/&amp;lt;template&amp;gt;&lt;/code> function will use the directory name of your current working directory to &amp;ldquo;name&amp;rdquo; your new content.
To override this behaviour use the &lt;code>--name&lt;/code> or &lt;code>-n&lt;/code> flag.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pct new &amp;lt;author&amp;gt;/&amp;lt;template&amp;gt; --name MyProject
&lt;/code>&lt;/pre>&lt;/div>&lt;p>By default the &lt;code>new &amp;lt;author&amp;gt;/&amp;lt;template&amp;gt;&lt;/code> function will output the template content to the current working directory.
To override this behavour use the &lt;code>--output&lt;/code> or &lt;code>-o&lt;/code> flag.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pct new &amp;lt;author&amp;gt;/&amp;lt;template&amp;gt; --output /path/to/your/project
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong>
Not all templates require a &lt;code>name&lt;/code>.
If a template doesn&amp;rsquo;t require one, providing a value to the &lt;code>--name&lt;/code> parameter will have no effect on the generated content.&lt;/p>
&lt;/blockquote>
&lt;h3 id="example-workflows">Example workflows&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">cd&lt;/span> /home/me/projects/MyBoltProject
&amp;gt; pct new puppetlabs/bolt-project
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&amp;gt; pct new puppet-module -n MyNewProject -o /home/me/projects/
&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">cd&lt;/span> /home/me/projects/MyNewProject
&amp;gt; pct new puppetlabs/puppet-fact -n ApplicationVersion
&amp;gt; pct new puppetlabs/rsapi-provider -n Awesomething
&amp;gt; pct new puppetlabs/puppet-transport -n AwesomethingApi
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="template-updates">Template Updates&lt;/h3>
&lt;p>At this time &lt;code>pct new&lt;/code> will &lt;strong>NOT&lt;/strong> update existing code to a newer version of a template.&lt;/p>
&lt;p>If you run a &lt;code>pct new&lt;/code> command using a &lt;code>project&lt;/code> template, the project will replace the content within the output directory with the template code.&lt;/p>
&lt;p>If you run a &lt;code>pct new&lt;/code> command using an &lt;code>item&lt;/code> template, the item will suppliment the content within the output directory with the template code. If files / folders that are named the same as the template content already exist, it will overwite this content.&lt;/p></description></item><item><title>Docs: Installation</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/install/</guid><description>
&lt;p>While the PCT is in early release, we provide an archive and a simple script to unpack it. When we move closer to a full release we will add a platform specific installer. Use the &lt;code>install.[ps1|sh]&lt;/code> script, depending upon your OS:&lt;/p>
&lt;h3 id="bash">Bash&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl -L https://pup.pt/pct/install.sh | sh
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="powershell">PowerShell&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="color:#8be9fd;font-style:italic">iex &lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&amp;amp;{ &lt;/span>$(&lt;span style="color:#8be9fd;font-style:italic">irm &lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;https://pup.pt/pct/install.ps1&amp;#39;&lt;/span>)&lt;span style="color:#f1fa8c">; Install-Pct }&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will install the latest release of PCT to &lt;code>~/.puppetlabs/pct&lt;/code>.&lt;/p>
&lt;p>&lt;img src="https://github.com/puppetlabs/pct/blob/main/docs/_resources/install_and_export_path.gif?raw=true" alt="install_pct">&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Warning!&lt;/strong>&lt;/p>
&lt;p>If you do not use the install script and are extracting the archive yourself, be sure to use the fully qualified path to &lt;code>~/.puppetlabs/pct&lt;/code> on *nix or &lt;code>$HOME/.puppetlabs/pct&lt;/code> on Windows when you set your &lt;code>PATH&lt;/code> environment variable.&lt;/p>
&lt;/blockquote>
&lt;p>A version of the product, with telemetry functionality disabled, is available too.
See &lt;a href="#installing-telemetry-free-version">here&lt;/a> for instructions on how to install it.&lt;/p>
&lt;h3 id="setting-up-tab-completion">Setting up Tab Completion&lt;/h3>
&lt;p>After installation, we&amp;rsquo;d highly recommend setting up tab completion for your shell to ensure the best possible experience.&lt;/p>
&lt;p>PCT has built in tab completion support for the following shells: &lt;code>bash&lt;/code>, &lt;code>zsh&lt;/code>, &lt;code>fish&lt;/code> and &lt;code>powershell&lt;/code>.&lt;/p>
&lt;p>To view the install instructions, access the &lt;code>--help&lt;/code> menu in &lt;code>pct completion&lt;/code> and follow the instructions for your shell:&lt;/p>
&lt;p>&lt;img src="https://github.com/puppetlabs/pct/blob/main/docs/_resources/completion_setup.gif?raw=true" alt="tab_completion">&lt;/p>
&lt;h2 id="installing-telemetry-free-version">Installing Telemetry Free Version&lt;/h2>
&lt;p>As of &lt;code>0.5.0&lt;/code>, we have been gathering telemetry data to provide insights in to how our products are being used.&lt;/p>
&lt;p>The following data is collected:&lt;/p>
&lt;ul>
&lt;li>Version of application in use&lt;/li>
&lt;li>OS / platform of the device&lt;/li>
&lt;li>What commands have been invoked (including command args)&lt;/li>
&lt;li>Any errors that occurred when running the application&lt;/li>
&lt;/ul>
&lt;p>We understand that there will be some users who prefer to have no telemetry data sent.
For those users, we offer a version of PCT with the telemetry functionality disabled.&lt;/p>
&lt;p>To install:&lt;/p>
&lt;h3 id="bash-1">Bash&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl -L https://pup.pt/pct/install.sh | sh -s -- --no-telemetry
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="powershell-1">PowerShell&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="color:#8be9fd;font-style:italic">iex &lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&amp;amp;{ &lt;/span>$(&lt;span style="color:#8be9fd;font-style:italic">irm &lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;https://pup.pt/pct/install.ps1&amp;#39;&lt;/span>)&lt;span style="color:#f1fa8c">; Install-Pct -NoTelemetry }&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will install the latest release of PCT, without telemetry functionality, to &lt;code>~/.puppetlabs/pct&lt;/code>.&lt;/p></description></item><item><title>Docs: Installation</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/install/</guid><description>
&lt;p>While PRM is in early release, we provide an archive and a simple script to unpack it.
When we move closer to a full release we will add a platform specific installer.
Use the &lt;code>install.[ps1|sh]&lt;/code> script, depending upon your OS:&lt;/p>
&lt;h3 id="bash">Bash&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl -L https://pup.pt/prm/install.sh | sh
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="powershell">PowerShell&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="color:#8be9fd;font-style:italic">iex &lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&amp;amp;{ &lt;/span>$(&lt;span style="color:#8be9fd;font-style:italic">irm &lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;https://pup.pt/prm/install.ps1&amp;#39;&lt;/span>)&lt;span style="color:#f1fa8c">; Install-Prm }&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will install the latest release of PRM to &lt;code>~/.puppetlabs/prm&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Warning!&lt;/strong>&lt;/p>
&lt;p>If you do not use the install script and are extracting the archive yourself, be sure to use the fully qualified path to &lt;code>~/.puppetlabs/prm&lt;/code> on *nix or &lt;code>$HOME/.puppetlabs/prm&lt;/code> on Windows when you set your &lt;code>PATH&lt;/code> environment variable.&lt;/p>
&lt;/blockquote>
&lt;p>A version of the product, with telemetry functionality disabled, is available too.
See &lt;a href="#installing-telemetry-free-version">here&lt;/a> for instructions on how to install it.&lt;/p>
&lt;h3 id="setting-up-tab-completion">Setting up Tab Completion&lt;/h3>
&lt;p>After installation, we&amp;rsquo;d highly recommend setting up tab completion for your shell to ensure the best possible experience.&lt;/p>
&lt;p>PRM has built in tab completion support for the following shells: &lt;code>bash&lt;/code>, &lt;code>zsh&lt;/code>, &lt;code>fish&lt;/code> and &lt;code>powershell&lt;/code>.&lt;/p>
&lt;p>To view the install instructions, run &lt;code>prm completion --help&lt;/code> and follow the instructions for your shell.&lt;/p>
&lt;h2 id="installing-telemetry-free-version">Installing Telemetry Free Version&lt;/h2>
&lt;p>As of &lt;code>0.5.0&lt;/code>, we have been gathering telemetry data to provide insights in to how our products are being used.&lt;/p>
&lt;p>The following data is collected:&lt;/p>
&lt;ul>
&lt;li>Version of application in use&lt;/li>
&lt;li>OS / platform of the device&lt;/li>
&lt;li>What commands have been invoked (including command args)&lt;/li>
&lt;li>Any errors that occurred when running the application&lt;/li>
&lt;/ul>
&lt;p>We understand that there will be some users who prefer to have no telemetry data sent.
For those users, we offer a version of PRM with the telemetry functionality disabled.&lt;/p>
&lt;p>To install:&lt;/p>
&lt;h3 id="bash-1">Bash&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl -L https://pup.pt/prm/install.sh | sh -s -- --no-telemetry
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="powershell-1">PowerShell&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="color:#8be9fd;font-style:italic">iex &lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&amp;amp;{ &lt;/span>$(&lt;span style="color:#8be9fd;font-style:italic">irm &lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;https://pup.pt/prm/install.ps1&amp;#39;&lt;/span>)&lt;span style="color:#f1fa8c">; Install-Prm -NoTelemetry }&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will install the latest release of PRM, without telemetry functionality, to &lt;code>~/.puppetlabs/prm&lt;/code>.&lt;/p></description></item><item><title>Docs: Installing Tools</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/usage/tool_installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/usage/tool_installation/</guid><description>
&lt;p>This document explains how you can install tools to execute with PRM.&lt;/p>
&lt;p>By default, tools are installed to the &lt;code>tools&lt;/code> folder alongside PRM unless the &lt;code>toolpath&lt;/code> flag is specified with an alternate location.&lt;/p>
&lt;h3 id="local-archive">Local archive&lt;/h3>
&lt;p>Tool packages can be installed locally using the &lt;code>prm install&lt;/code> command.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">prm install ~/my-tool-1.2.3.tar.gz
&lt;/code>&lt;/pre>&lt;/div>&lt;p>That command will install the tool contained in &lt;code>my-tool-1.2.3.tar.gz&lt;/code> to the default location.&lt;/p>
&lt;h3 id="remote-archive">Remote archive&lt;/h3>
&lt;p>Tool packages stored remotely can be automatically downloaded and extracted with &lt;code>prm install&lt;/code> so long as you know the URL to where the archive is.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">prm install https://packages.mycompany.com/prm/my-tool-1.2.3.tar.gz
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This command will attempt to download the PRM tool from the specified url and then install it like any other locally available PRM tool archive.&lt;/p>
&lt;h3 id="remote-git-repository">Remote git repository&lt;/h3>
&lt;p>&lt;strong>Git&lt;/strong> must be installed for this feature to work. The git repository must contain only one tool and must be structured with the &lt;code>prm-config.yml&lt;/code> file and the &lt;code>content&lt;/code> directory in the root directory of the repository.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">prm install --git-uri https://github.com/myorg/myawesometool
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This command will attempt to clone the PRM tool from the git repository at the specified URI and then install it to the default tool location.&lt;/p>
&lt;h3 id="force-tool-installation">Force tool installation&lt;/h3>
&lt;p>Adding the &lt;code>-f&lt;/code> or the &lt;code>--force&lt;/code> flag to the &lt;code>prm install&lt;/code> command will forcefully install/overwrite a tool if there is a tool installed with the same &lt;code>author&lt;/code>, &lt;code>name&lt;/code> and &lt;code>version&lt;/code>.&lt;/p>
&lt;h3 id="updating-tools">Updating tools&lt;/h3>
&lt;p>While there is no &lt;code>update&lt;/code> command, newer versions of tools can be installed like any other tool package.&lt;/p>
&lt;p>Currently, only the latest version of a selected tool is executable; the ability to select an older version of the tool to execute will be added in the future.&lt;/p>
&lt;h3 id="list-installed-tools">List installed tools&lt;/h3>
&lt;p>Installed tools can be listed by running the command &lt;code>prm exec --list&lt;/code>, displayed in the following format:&lt;/p>
&lt;p>&lt;img src="https://github.com/puppetlabs/prm/blob/main/docs/md/content/images/exec-list-tools.png?raw=true" alt="prm tool list screenshot">&lt;/p>
&lt;p>The &lt;code>--toolpath&lt;/code> flag can also be added to list tools installed in an alternate location.&lt;/p></description></item><item><title>Docs: Telemetry</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/concepts/telemetry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/concepts/telemetry/</guid><description>
&lt;p>By default, PRM collects some telemetry during each run.
This information is non-identifying and does not include any personal or organizational details.&lt;/p>
&lt;p>We use it to see how PRM is being used so we can better understand issues, features, and what to prioritize as we move forward.
We emit this telemetry information to &lt;a href="https://honeycomb.io">Honeycomb&lt;/a> for introspection.
We keep the telemetry for 60 days, after which it ages out.&lt;/p>
&lt;h2 id="what-we-gather">What We Gather&lt;/h2>
&lt;p>Each PRM run reports the following data:&lt;/p>
&lt;ul>
&lt;li>The UTC timestamp for when the run started&lt;/li>
&lt;li>How long the command took to run&lt;/li>
&lt;li>The operating system architecture (x64, ARM, etc)&lt;/li>
&lt;li>The operating system type (darwin, linux, windows)&lt;/li>
&lt;li>A uniquely generated internal identifier for the machine running the command&lt;/li>
&lt;li>Whether or not the command ran in a CI environment&lt;/li>
&lt;li>The arguments passed to PRM in this run&lt;/li>
&lt;/ul>
&lt;p>This data allows us to see broadly how many machines the program is running on, what the breakdown of operating system/system architecture is, how performant the program is, and which commands are most used.&lt;/p>
&lt;p>When there is an error, PRM reports the error information as well - the stack trace information and the error message displayed to a user.
This lets us investigate issues to see how common they are and improve our testing and error handling.&lt;/p>
&lt;h2 id="running-prm-without-telemetry">Running PRM Without Telemetry&lt;/h2>
&lt;p>We know that some users do not want to report telemetry;
for those users, it is possible to install a &amp;ldquo;notel&amp;rdquo; version of the binary which does not include the telemetry bits at all.
This binary is identical to the standard binary save that it does not have any mechanisms for recording or sending telemetry data.&lt;/p>
&lt;p>For those users, an alternate install is available.&lt;/p>
&lt;p>To install:&lt;/p>
&lt;h3 id="bash">Bash&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">curl -L https://pup.pt/pdkgo/install.sh | sh -s -- --no-telemetry
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="powershell">PowerShell&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="color:#8be9fd;font-style:italic">iex &lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&amp;amp;{ &lt;/span>$(&lt;span style="color:#8be9fd;font-style:italic">irm &lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;https://pup.pt/pdkgo/install.ps1&amp;#39;&lt;/span>)&lt;span style="color:#f1fa8c">; Install-Pct -NoTelemetry }&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Validating Puppet Content</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/usage/validate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/usage/validate/</guid><description>
&lt;p>In this guide you&amp;rsquo;ll learn how the validate command works and how to use
it to quickly validate your Puppet content.&lt;/p>
&lt;h4 id="what-is-a-validator">What is a validator&lt;/h4>
&lt;p>A validator is a tool which can read and validate a codebase of Puppet content.&lt;/p>
&lt;p>The configuration of a validator is almost identical to that of a normal
tool. The only difference is that validators contain the &lt;code>can_validate: true&lt;/code>
property in their &lt;code>prm-config.yml&lt;/code> configuration file.&lt;/p>
&lt;p>All validation tools in a tool directory can be listed with the following command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">prm validate --list
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="how-to-use-the-validate-command">How to use the validate command&lt;/h3>
&lt;h4 id="single-tool-validation">Single tool validation&lt;/h4>
&lt;p>It is very easy to validate with a single tool. The command below shows an
outline of the core arguments and flags necessary for content validation:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">prm validate &lt;span style="color:#ff79c6">{&lt;/span>author/tool&lt;span style="color:#ff79c6">}&lt;/span> --codedir &lt;span style="color:#ff79c6">{&lt;/span>location/of/code&lt;span style="color:#ff79c6">}&lt;/span> --toolArgs&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;{any, tool, args}&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here is an example of a command composed to validate &lt;code>epp&lt;/code> content against the current directory,
specifically, &lt;code>dir1&lt;/code> and &lt;code>dir2&lt;/code> as specified by the &lt;code>toolArgs&lt;/code> flag.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">prm validate puppetlabs/epp --codedir . --toolArgs&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;dir1, dir2&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When the command is executed PRM will validate with the &lt;code>epp&lt;/code> tool using the appropriate tool
arguments; the tool arguments in this case will instruct epp to validate content in the specified directories.&lt;/p>
&lt;h4 id="multi-tool-validation">Multi-tool validation&lt;/h4>
&lt;p>PRM supports running multiple validation tools simultaneously. That&amp;rsquo;s where the
&lt;code>validate.yml&lt;/code> file comes in; it allows you to arrange validators into groups.&lt;/p>
&lt;p>After grouping validators in a &lt;code>validate.yml&lt;/code> file, you can easily run a group of validators
from a single command. See below for usage of multi-tool validation.&lt;/p>
&lt;h5 id="example-of-a-validateyml-file">Example of a &lt;code>validate.yml&lt;/code> file&lt;/h5>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#ff79c6">groups&lt;/span>:
- &lt;span style="color:#ff79c6">id&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;ci&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">tools&lt;/span>:
- &lt;span style="color:#ff79c6">name&lt;/span>: puppetlabs/epp
&lt;span style="color:#ff79c6">args&lt;/span>: [--example, args]
- &lt;span style="color:#ff79c6">name&lt;/span>: puppetlabs/parser
- &lt;span style="color:#ff79c6">name&lt;/span>: puppetlabs/puppet-lint
- &lt;span style="color:#ff79c6">name&lt;/span>: puppetlabs/onceover
- &lt;span style="color:#ff79c6">id&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;quick_validate&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">tools&lt;/span>:
- &lt;span style="color:#ff79c6">name&lt;/span>: puppetlabs/epp
- &lt;span style="color:#ff79c6">name&lt;/span>: puppetlabs/rubocop
- &lt;span style="color:#ff79c6">name&lt;/span>: puppetlabs/parser
- &lt;span style="color:#ff79c6">name&lt;/span>: puppetlabs/r10k
- &lt;span style="color:#ff79c6">id&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;syntax_validation&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">tools&lt;/span>:
- &lt;span style="color:#ff79c6">name&lt;/span>: puppetlabs/puppet-syntax
- &lt;span style="color:#ff79c6">name&lt;/span>: puppetlabs/metadata-json-lint
- &lt;span style="color:#ff79c6">name&lt;/span>: puppetlabs/puppet-lint
&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">Note&lt;/h4>
The &lt;code>validate.yml&lt;/code> file should be stored in the &lt;strong>root&lt;/strong> of the Puppet content codebase
which is to be validated.
&lt;/div>
&lt;h5 id="group-flag">&lt;code>group&lt;/code> flag&lt;/h5>
&lt;p>The &lt;code>--group {string}&lt;/code> flag can be used to specify which group of validators to run, e.g.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">prm validate --codedir . --group syntax_validation
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When the command is executed PRM will validate with the &lt;code>syntax_validation&lt;/code> group of validators.&lt;/p>
&lt;h5 id="workercount-flag">&lt;code>workerCount&lt;/code> flag&lt;/h5>
&lt;p>The &lt;code>--workerCount {int}&lt;/code> flag can be used to specify how many validators will run simultaneously; e.g.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">prm validate --codedir . --group syntax_validation --workerCount &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When the command is executed PRM will validate with the &lt;code>syntax_validation&lt;/code> group of validators,
running a maximum of 2 validators concurrently.&lt;/p>
&lt;h5 id="serial-flag">&lt;code>serial&lt;/code> flag&lt;/h5>
&lt;p>The &lt;code>--serial&lt;/code> flag can be used to specify that only one validator should be run a time; e.g.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">prm validate --codedir . --group syntax_validation --serial
&lt;/code>&lt;/pre>&lt;/div>&lt;p>When the command is executed PRM will validate with the &lt;code>syntax_validation&lt;/code> group of validators,
running one validator at a time.&lt;/p>
&lt;h4 id="viewing-validation-results">Viewing validation results&lt;/h4>
&lt;p>PRM can currently output validation results to the terminal or to a
log file.&lt;/p>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">Note&lt;/h4>
When outputting to the terminal, PRM will only output &lt;code>stderr&lt;/code>, if there
is any; whereas both &lt;code>stdout&lt;/code> and &lt;code>stderr&lt;/code> are outputted to log files. This
is to prevent the terminal from becoming congested with verbose and
irrelevant text.
&lt;/div>
&lt;h5 id="default-output-locations">Default output locations&lt;/h5>
&lt;p>See below the default output locations for each type of validation:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Single tool&lt;/th>
&lt;th>Multi-tool&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>terminal&lt;/td>
&lt;td>file&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5 id="resultsview-flag">&lt;code>resultsView&lt;/code> flag&lt;/h5>
&lt;p>The &lt;code>--resultsView {terminal|file}&lt;/code> can be used to specify where you want the results of validation to output
to.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">prm validate puppetlabs/epp --codedir . --resultsView file
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The results of this validation will be sent to a log file, overriding the default output for single tool
validation, which is the terminal.&lt;/p>
&lt;h4 id="example-of-multi-tool-results-outputted-to-the-terminal">Example of multi-tool results outputted to the terminal:&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ prm validate --codedir . --group syntax_validation --resultsView terminal
3:23PM INF Found tool group: syntax_validation
3:23PM INF Validating with the puppet-syntax tool
3:23PM INF Validating with the puppet-lint tool
3:23PM INF Validating with the metadata-json-lint tool
3:24PM ERR puppet-syntax:
---&amp;gt; syntax:manifests
---&amp;gt; syntax:templates
ERRORS:
Syntax error at &lt;span style="color:#f1fa8c">&amp;#39;Kernel&amp;#39;&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>file: templates/motd.epp, line: 5, column: 1&lt;span style="color:#ff79c6">)&lt;/span>
TOOL NAME | VALIDATION EXIT CODE
---------------------+-----------------------
puppet-syntax | &lt;span style="color:#bd93f9">1&lt;/span>
metadata-json-lint | &lt;span style="color:#bd93f9">0&lt;/span>
puppet-lint | &lt;span style="color:#bd93f9">0&lt;/span>
3:24PM ERR Validation returned &lt;span style="color:#bd93f9">1&lt;/span> error
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="example-of-multi-tool-results-outputted-to-the-log-files">Example of multi-tool results outputted to the log files:&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#6272a4"># No need to specify the --resultsView flag here as it defaults to `file` for mulit-tool validation&lt;/span>
$ prm validate --codedir . --group syntax_validation
3:49PM INF Found tool group: syntax_validation
3:49PM INF Validating with the metadata-json-lint tool
3:49PM INF Validating with the puppet-syntax tool
3:49PM INF Validating with the puppet-lint tool
TOOL NAME | VALIDATION EXIT CODE | FILE LOCATION
---------------------+----------------------+--------------------------------------------------------------------------------
puppet-syntax | &lt;span style="color:#bd93f9">1&lt;/span> | .prm-validate/syntax_validation/puppet-syntax_2022_April_26_16-49-59.log
metadata-json-lint | &lt;span style="color:#bd93f9">0&lt;/span> | .prm-validate/syntax_validation/metadata-json-lint_2022_April_26_16-49-59.log
puppet-lint | &lt;span style="color:#bd93f9">0&lt;/span> | .prm-validate/syntax_validation/puppet-lint_2022_April_26_16-49-59.log
3:49PM ERR Validation returned &lt;span style="color:#bd93f9">1&lt;/span> error
&lt;/code>&lt;/pre>&lt;/div>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">Note&lt;/h4>
Support for formatting of the validation results will be implemented in a future
release. E.g. JSON or JUNIT
&lt;/div></description></item><item><title>Docs: Anatomy of a PRM Tool</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/concepts/tool-anatomy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/concepts/tool-anatomy/</guid><description>
&lt;h2 id="structure">Structure&lt;/h2>
&lt;p>A PRM tool can be packaged as a &lt;code>.tar.gz&lt;/code> or hosted in a Github repository.
Tools are how PRM knows to take defined actions against a file or folder; linting, testing, exporting, etc.&lt;/p>
&lt;p>A tool can be:&lt;/p>
&lt;ul>
&lt;li>a Ruby gem,&lt;/li>
&lt;li>an executable binary,&lt;/li>
&lt;li>or a container.&lt;/li>
&lt;/ul>
&lt;h2 id="composition">Composition&lt;/h2>
&lt;p>At a minimum, a PRM tool must contain a &lt;code>prm-config.yml&lt;/code> in the root directory.&lt;/p>
&lt;p>Optionally, you may include a &lt;code>content&lt;/code> directory, also at the root.
The &lt;code>content&lt;/code> directory can contain scripts, binaries, config files, etc. required to supplement the functionality of the tool outside the parameters of the configuration file.&lt;/p>
&lt;p>When a tool is used with the Docker backend, everything in the &lt;code>content&lt;/code> directory is mounted to &lt;code>/tmp&lt;/code> in the container;
e.g. &lt;code>content/myfile.sh&lt;/code> will be mounted to &lt;code>/tmp/myfile.sh&lt;/code>.&lt;/p>
&lt;h3 id="required-parameters">Required Parameters&lt;/h3>
&lt;p>All tools &lt;strong>must&lt;/strong> include mandatory metadata in the &lt;code>prm-config.yml&lt;/code> file which enumerate it for PRM to understand what it is.
They must include:&lt;/p>
&lt;ul>
&lt;li>the author (alphanumeric characters, dashes, and underscores only),&lt;/li>
&lt;li>a short id for the tool (alphanumeric characters, dashes, and underscores only),&lt;/li>
&lt;li>a display name (an arbitrary string which &lt;em>can&lt;/em> include spaces),&lt;/li>
&lt;li>a semantic version,&lt;/li>
&lt;li>and a url to the &lt;em>upstream&lt;/em> project the tool enables users to leverage (e.g., rubocop&amp;rsquo;s landing page)&lt;/li>
&lt;/ul>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#ff79c6">plugin&lt;/span>:
&lt;span style="color:#ff79c6">author&lt;/span>: fantastic-me
&lt;span style="color:#ff79c6">id&lt;/span>: awesome-tool
&lt;span style="color:#ff79c6">display&lt;/span>: Awesome Tool
&lt;span style="color:#ff79c6">version&lt;/span>: &lt;span style="color:#bd93f9">0.1.0&lt;/span>
&lt;span style="color:#ff79c6">upstream_project_url&lt;/span>: https://github.com/fantastic-me/awesome-me
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Tools are executed by namespace, always in the form &lt;code>author/id&lt;/code>.
To execute the example tool above, you would run the command &lt;code>prm exec fantastic-me/awesome-tool&lt;/code>&lt;/p>
&lt;h3 id="common-parameters">Common Parameters&lt;/h3>
&lt;p>In addition to the &lt;code>plugin&lt;/code> configuration items, there is a &lt;code>common&lt;/code> section that contains parameters that change the behavior of the tool regardless of underlying implementation details.&lt;/p>
&lt;dl>
&lt;dt>&lt;code>can_validate&lt;/code>&lt;/dt>
&lt;dd>Set this to &lt;code>true&lt;/code> if the tool is meant to validate a target code directory.&lt;/dd>
&lt;dd>Defaults to &lt;code>false&lt;/code>&lt;/dd>
&lt;/dl>
&lt;!-- Force a break between definitions -->
&lt;dl>
&lt;dt>&lt;code>help_arg&lt;/code>&lt;/dt>
&lt;dd>Set this to the argument the tool expects to be passed to display its help info.&lt;/dd>
&lt;dd>Defaults to &lt;code>--help&lt;/code>.&lt;/dd>
&lt;/dl>
&lt;!-- Uncomment when these when implemented
`interleave_stdout_err`
: Should the stdout &amp; stderr be interleaved in to one stream, as opposed to separate ones?
: Defaults to `false`.
`needs_write_access`
: Will the execution of this tool require RW permissions against the target code dir?
: Defaults to `false`.
-->
&lt;dl>
&lt;dt>&lt;code>sucess_exit_code&lt;/code>&lt;/dt>
&lt;dd>Set this to the integer that the tool will exit with if it runs successfully.&lt;/dd>
&lt;dd>Defaults to &lt;code>0&lt;/code>.&lt;/dd>
&lt;/dl>
&lt;!-- Force a break between definitions -->
&lt;dl>
&lt;dt>&lt;code>default_args&lt;/code>&lt;/dt>
&lt;dd>Set this to an array of arguments to pass to the tool by default; these can be overridden with the &lt;code>toolArgs&lt;/code> flag when executed.&lt;/dd>
&lt;dd>No default value.&lt;/dd>
&lt;/dl>
&lt;!-- Force a break between definitions -->
&lt;dl>
&lt;dt>&lt;code>env&lt;/code>&lt;/dt>
&lt;dd>Set this to a map of environment variable names and their values to be set automatically prior to tool execution.&lt;/dd>
&lt;dd>No default value.&lt;/dd>
&lt;/dl>
&lt;!-- Uncomment when this is implemented
`output_mode`
: The output mode (`junit|json|yaml`)
: No default value.
-->
&lt;dl>
&lt;dt>&lt;code>requires_git&lt;/code>&lt;/dt>
&lt;dd>Set this to &lt;code>true&lt;/code> if the tool requires a &lt;code>git&lt;/code> binary.&lt;/dd>
&lt;dd>No default value.&lt;/dd>
&lt;/dl>
&lt;!-- Force a break between definitions -->
&lt;dl>
&lt;dt>&lt;code>use_script&lt;/code>&lt;/dt>
&lt;dd>Set this to the name of a script that will be invoked to execute the tool.&lt;/dd>
&lt;dd>The name &lt;strong>should not&lt;/strong> include the file extension (e.g. &lt;code>runme.sh&lt;/code> -&amp;gt; &lt;code>use_script: runme&lt;/code>).&lt;/dd>
&lt;dd>The script &lt;strong>should&lt;/strong> be present in the &lt;code>content&lt;/code> directory and have execute permissions set.&lt;/dd>
&lt;dd>The script &lt;strong>should&lt;/strong> have execute permissions set prior to packaging the tool (ie &lt;code>chmod +x runme.sh&lt;/code>).&lt;/dd>
&lt;dd>No default value.&lt;/dd>
&lt;/dl>
&lt;h4 id="example-common-parameters">Example Common Parameters&lt;/h4>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#ff79c6">common&lt;/span>:
&lt;span style="color:#ff79c6">can_validate&lt;/span>: &lt;span style="color:#ff79c6">true&lt;/span>
&lt;span style="color:#ff79c6">help_arg&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#39;-h&amp;#39;&lt;/span>
&lt;span style="color:#ff79c6">success_exit_code&lt;/span>: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;span style="color:#ff79c6">default_args&lt;/span>: [&lt;span style="color:#f1fa8c">&amp;#39;--include-tempfiles&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;--fail-fast&amp;#39;&lt;/span>]
&lt;span style="color:#ff79c6">env&lt;/span>:
- &lt;span style="color:#ff79c6">&amp;#34;TARGET_VERSION&amp;#34;: &lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;1.2.3&amp;#34;&lt;/span>
- &lt;span style="color:#ff79c6">&amp;#34;CONFIG_FILE&amp;#34;: &lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;/code/config.yaml&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">requires_git&lt;/span>: &lt;span style="color:#ff79c6">true&lt;/span>
&lt;span style="color:#ff79c6">use_script&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;collate_files_and_run&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This tool, as configured:&lt;/p>
&lt;ol>
&lt;li>Can be used with &lt;code>prm validate&lt;/code>&lt;/li>
&lt;li>Will pass &lt;code>-h&lt;/code> to retrieve the help information for the underlying tool&lt;/li>
&lt;li>Will treat &lt;em>only&lt;/em> executions with an exit code of &lt;code>2&lt;/code> as successful&lt;/li>
&lt;li>Will by default append &lt;code>--include-tempfiles --fail-fast&lt;/code> when executed&lt;/li>
&lt;li>Will set the &lt;code>TARGET_VERSION&lt;/code> environment variable to &lt;code>1.2.3&lt;/code> and the &lt;code>CONFIG_FILE&lt;/code> environment variable to &lt;code>/code/config.yaml&lt;/code> in the execution context&lt;/li>
&lt;li>Does require &lt;code>git&lt;/code> to be installed/available&lt;/li>
&lt;li>Will use the &lt;code>collate_files_and_run.sh&lt;/code> in the &lt;code>content&lt;/code> directory to execute the tool.&lt;/li>
&lt;/ol>
&lt;h3 id="gem-tools">Gem Tools&lt;/h3>
&lt;p>All &lt;code>gem&lt;/code> based tools must declare which gems must be installed and the name of the executable to run.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#ff79c6">gem&lt;/span>:
&lt;span style="color:#ff79c6">name&lt;/span>: [amazing_gem, dependency_gem, another_dependency_gem]
&lt;span style="color:#ff79c6">executable&lt;/span>: amazing_gem
&lt;/code>&lt;/pre>&lt;/div>&lt;p>By default, any gems specified will always attempt to resolve and use the &lt;em>latest&lt;/em> released version.&lt;/p>
&lt;p>If there are compatibility concerns, version pins by Ruby version can be enumerated under the &lt;code>compatibility&lt;/code> section.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#ff79c6">gem&lt;/span>:
&lt;span style="color:#ff79c6">name&lt;/span>: [amazing_gem, dependency_gem, another_dependency_gem]
&lt;span style="color:#ff79c6">executable&lt;/span>: amazing_gem
&lt;span style="color:#ff79c6">compatibility&lt;/span>:
- &lt;span style="color:#ff79c6">2.6&lt;/span>:
- &lt;span style="color:#ff79c6">&amp;#34;amazing_gem&amp;#34;: &lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;2.15.0&amp;#34;&lt;/span>
- &lt;span style="color:#ff79c6">2.7&lt;/span>:
- &lt;span style="color:#ff79c6">&amp;#34;amazing_gem&amp;#34;: &lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;~&amp;gt; 3.0&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will install the latest versions of &lt;code>dependency_gem&lt;/code> and &lt;code>another_dependency_gem&lt;/code> regardless of Ruby version.&lt;/p>
&lt;p>For any version of Ruby other than &lt;code>2.6&lt;/code> and &lt;code>2.7&lt;/code>, the tool will expect to use the latest version of &lt;code>amazing_gem&lt;/code> as well.
For Ruby 2.6, &lt;code>amazing_gem&lt;/code> will only ever be used at version &lt;code>2.15.0&lt;/code>.
For Ruby 2.7, &lt;code>amazing_gem&lt;/code> will always use the latest version greater than or equal to &lt;code>3.0&lt;/code> and less than &lt;code>4.0&lt;/code>.&lt;/p>
&lt;h3 id="binary-tools">Binary Tools&lt;/h3>
&lt;p>All &lt;code>binary&lt;/code> based tools must declare the name of the binary which is to be run and installation steps for acquiring that binary on particular platforms.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#ff79c6">binary&lt;/span>:
&lt;span style="color:#ff79c6">name&lt;/span>: my_tool
&lt;span style="color:#ff79c6">install_steps&lt;/span>:
&lt;span style="color:#ff79c6">windows&lt;/span>: |&lt;span style="color:#f1fa8c">
&lt;/span>&lt;span style="color:#f1fa8c"> # Windows specific install steps
&lt;/span>&lt;span style="color:#f1fa8c"> choco install my_tool&lt;/span>
&lt;span style="color:#ff79c6">linux&lt;/span>: |&lt;span style="color:#f1fa8c">
&lt;/span>&lt;span style="color:#f1fa8c"> # Linux specific install steps
&lt;/span>&lt;span style="color:#f1fa8c"> rpm install my_tool&lt;/span>
&lt;span style="color:#ff79c6">darwin&lt;/span>: |&lt;span style="color:#f1fa8c">
&lt;/span>&lt;span style="color:#f1fa8c"> # MacOS specific install steps
&lt;/span>&lt;span style="color:#f1fa8c"> brew install my_tool&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This configuration will expect to find &lt;code>my_tool&lt;/code> on the &lt;code>PATH&lt;/code> and calls out installation steps for Windows, Linux, and MacOS.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong> At this time, only Linux docker containers are supported.
Future releases will support other platforms and backends.&lt;/p>
&lt;/blockquote>
&lt;h3 id="container-tools">Container Tools&lt;/h3>
&lt;p>All &lt;code>container&lt;/code> based tools must declare the image name and tag to be used.
The images must be available or retrievable by Docker on the machine running PRM.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#ff79c6">container&lt;/span>:
&lt;span style="color:#ff79c6">name&lt;/span>: myorg/myimage
&lt;span style="color:#ff79c6">tag&lt;/span>: latest
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This configuration will execute in the &lt;code>myorg/myimage:latest&lt;/code> container.&lt;/p></description></item><item><title>Docs: Quick Start Guide</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/quick-start/</guid><description>
&lt;p>This quick start guide will show you how to:&lt;/p>
&lt;ul>
&lt;li>Create a &amp;ldquo;bare bones&amp;rdquo; Puppet module from the &lt;code>puppet-module-base&lt;/code> project template&lt;/li>
&lt;li>Add a Puppet Class to the module&lt;/li>
&lt;li>Add a Github Actions Workflow to test the module against the currently supported Puppet versions&lt;/li>
&lt;/ul>
&lt;h3 id="step-1-create-a-puppet-module">&lt;strong>STEP 1:&lt;/strong> Create a Puppet Module&lt;/h3>
&lt;p>Let&amp;rsquo;s name our module &lt;code>test_module&lt;/code> using the &lt;code>-n&lt;/code> flag:
&lt;img src="https://github.com/puppetlabs/pct/blob/main/docs/_resources/new_module.gif?raw=true" alt="new_project_template">&lt;/p>
&lt;h3 id="step-2-add-a-new-class">&lt;strong>STEP 2:&lt;/strong> Add a New Class&lt;/h3>
&lt;p>If we &lt;code>cd&lt;/code> in to the module root dir, everything will get deployed with the correct layout:
&lt;img src="https://github.com/puppetlabs/pct/blob/main/docs/_resources/new_class.gif?raw=true" alt="new_class">&lt;/p>
&lt;h3 id="step-3-add-a-github-actions-workflow">&lt;strong>STEP 3:&lt;/strong> Add a Github Actions Workflow&lt;/h3>
&lt;p>Want to know what configurable parameters are availble for a template and their defaults?
Run &lt;code>pct new --info &amp;lt;TEMPLATE_AUTHOR&amp;gt;/&amp;lt;TEMPLATE_ID&amp;gt;&lt;/code>:&lt;/p>
&lt;p>&lt;img src="https://github.com/puppetlabs/pct/blob/main/docs/_resources/new_info.gif?raw=true" alt="new_info">&lt;/p>
&lt;p>We&amp;rsquo;re happy with those defaults, so let&amp;rsquo;s deploy this item.&lt;/p>
&lt;p>Since we&amp;rsquo;re outside the module root dir, we&amp;rsquo;ll use the &lt;code>-o&lt;/code> option to point at the root dir:&lt;/p>
&lt;p>&lt;img src="https://github.com/puppetlabs/pct/blob/main/docs/_resources/new_ghactions.gif?raw=true" alt="new_info">&lt;/p></description></item><item><title>Docs: Quick Start Guide</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/quick-start/</guid><description>
&lt;p>This quick start guide will show you how to:&lt;/p>
&lt;ul>
&lt;li>Select a Puppet version to run against&lt;/li>
&lt;li>Check for available tools&lt;/li>
&lt;li>Generate reference docs for a Puppet module&lt;/li>
&lt;/ul>
&lt;p>It assumes you have already installed PRM.&lt;/p>
&lt;h2 id="select-a-puppet-version">Select a Puppet Version&lt;/h2>
&lt;p>By default, PRM is set to use Puppet 7.15.0 as the runtime environment.
We can verify that:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">prm get puppet
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">4:35PM INF Puppet version is configured to: 7.15.0
&lt;/code>&lt;/pre>&lt;/div>&lt;p>To change the Puppet runtime version, we use the &lt;code>prm set&lt;/code> command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">prm &lt;span style="color:#8be9fd;font-style:italic">set&lt;/span> puppet 6.19.1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And then confirm that the correct version has been set:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">prm get puppet
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">4:36PM INF Puppet version is configured to: 6.19.1
&lt;/code>&lt;/pre>&lt;/div>&lt;p>From this point on, PRM will be executing in the &lt;code>6.19.1&lt;/code> Puppet runtime.
For the list of available versions, see the &lt;a href="https://hub.docker.com/r/puppet/puppet-agent/tags">Puppet Agent docker tag list&lt;/a>.
In this initial release, the runtime is tied to the published Puppet Agent Docker images.&lt;/p>
&lt;h2 id="check-available-tools">Check Available Tools&lt;/h2>
&lt;p>To see what tools are available by default, we can run a single command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">prm &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> --list
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Which by default returns a table view of available tools - including their name, author, project url, and version.&lt;/p>
&lt;p>&lt;img src="https://github.com/puppetlabs/prm/blob/main/docs/md/content/images/exec-list-tools.png?raw=true" alt="prm tool list screenshot">&lt;/p>
&lt;h2 id="generate-reference-docs">Generate Reference Docs&lt;/h2>
&lt;p>Reviewing the listed tools, we can see that there is a &lt;code>puppet-strings&lt;/code> tool.
By default, this tool runs the Puppet Strings command to verify the documentation status of the module.
We can point this at a folder containing a Puppet module to see the state of that module&amp;rsquo;s documentation.
In this example, we&amp;rsquo;re generating the reference documentation for the &lt;a href="https://forge.puppet.com/puppetlabs/acl">ACL module&lt;/a>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">prm &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> puppetlabs/puppet-strings --codedir ~/code/modules/puppetlabs-acl
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">4:54PM INF Creating new image. Please wait...
4:54PM INF Code path: ~/code/modules/puppetlabs-acl
4:54PM INF Cache path: ~/.pdk/prm/cache
4:54PM INF Additional Args: []
Files: 5
Modules: 2 ( 0 undocumented)
Classes: 4 ( 0 undocumented)
Constants: 25 ( 0 undocumented)
Attributes: 9 ( 0 undocumented)
Methods: 49 ( 0 undocumented)
Puppet Data Types: 0 ( 0 undocumented)
Puppet Data Type Aliases: 0 ( 0 undocumented)
Puppet Classes: 0 ( 0 undocumented)
Puppet Types: 1 ( 0 undocumented)
Puppet Providers: 1 ( 0 undocumented)
Puppet Functions: 0 ( 0 undocumented)
Puppet Defined Types: 0 ( 0 undocumented)
Puppet Plans: 0 ( 0 undocumented)
Puppet Tasks: 0 ( 0 undocumented)
100.00% documented
4:54PM INF Tool puppetlabs/puppet-strings executed successfully
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Behind the scenes, PRM built a docker container on the fly from the tool definition for &lt;code>puppet-strings&lt;/code> and then executed it against the specified directory.
The output we see without the PRM log prefix is what the docker container&amp;rsquo;s stdout returned;
in this case, the documentation results for the ACL module.&lt;/p>
&lt;p>We can also pass arbitrary arguments to the tool;
to generate the reference documentation, we need to specify that we want to generate the document and set the format to markdown.
This will create (or update if it exists) the &lt;code>REFERENCE.md&lt;/code> file in the module&amp;rsquo;s folder.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">prm &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> puppetlabs/puppet-strings --codedir ~/code/modules/puppetlabs-acl --toolArgs &lt;span style="color:#f1fa8c">&amp;#34;strings generate --format markdown&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">4:54PM INF Creating new image. Please wait...
4:54PM INF Code path: ~/code/modules/puppetlabs-acl
4:54PM INF Cache path: ~/.pdk/prm/cache
4:54PM INF Additional Args: [strings generate --format markdown]
Files: 5
Modules: 2 ( 0 undocumented)
Classes: 4 ( 0 undocumented)
Constants: 25 ( 0 undocumented)
Attributes: 9 ( 0 undocumented)
Methods: 49 ( 0 undocumented)
Puppet Data Types: 0 ( 0 undocumented)
Puppet Data Type Aliases: 0 ( 0 undocumented)
Puppet Classes: 0 ( 0 undocumented)
Puppet Types: 1 ( 0 undocumented)
Puppet Providers: 1 ( 0 undocumented)
Puppet Functions: 0 ( 0 undocumented)
Puppet Defined Types: 0 ( 0 undocumented)
Puppet Plans: 0 ( 0 undocumented)
Puppet Tasks: 0 ( 0 undocumented)
100.00% documented
4:54PM INF Tool puppetlabs/puppet-strings executed successfully
&lt;/code>&lt;/pre>&lt;/div>&lt;p>While the output of Puppet Strings itself isn&amp;rsquo;t any different, we can check the timestamp on the &lt;code>REFERENCE.md&lt;/code> file and verify that it was just updated (or created if it didn&amp;rsquo;t already exist).&lt;/p>
&lt;p>Now you know how to set the Puppet runtime for PRM, find a tool to execute, and execute that tool with additional arguments.&lt;/p></description></item><item><title>Docs: Using the Explain Subsystem</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/usage/explain-subsystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/usage/explain-subsystem/</guid><description>
&lt;p>The Explain subsystem is a built-in way to surface PRMs full documentation at the commandline with pretty formatting.
While our documentation is published online, sometimes it is useful to read it in the terminal you&amp;rsquo;re working from.&lt;/p>
&lt;p>There are three broad categories of documentation used in this project: reference, narrative, and concept.
The Explain subsystem is used to surface narrative and concept docs.&lt;/p>
&lt;p>Reference docs are surfaced using the built-in help subsystem by calling &lt;code>prm help &amp;lt;command&amp;gt;&lt;/code> or &lt;code>prm &amp;lt;command&amp;gt; --help&lt;/code>.&lt;/p>
&lt;p>Narrative docs are walkthroughs or guides which take you through a specific action or problem.
Concept docs are used to explain broader or deeper topics, like configuration and telemetry.&lt;/p>
&lt;p>This guide will walk you through how to look for and read narrative and concept documents from the terminal.&lt;/p>
&lt;h2 id="searching-for-topics">Searching for Topics&lt;/h2>
&lt;p>If you run &lt;code>prm explain&lt;/code> without any additional parameters, it will list all available topics into your terminal in a table format.
This will include the name, description, category, and any tags associated with each topic.&lt;/p>
&lt;p>You can also filter by category using the &lt;code>category&lt;/code> and &lt;code>tag&lt;/code> flags, including using them together.
Moreover, PRM already knows the available tags and categories, so if you&amp;rsquo;re using shell completion, you can tab or step through them.&lt;/p>
&lt;p>For example, the command below will display any topics which are part of the &lt;code>narrative&lt;/code> category and include the &lt;code>install&lt;/code> tag:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">prm explain --category narrative --tag install
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can also use shell completion to auto-complete the list of available topics directly.&lt;/p>
&lt;h2 id="displaying-a-single-topic">Displaying a Single Topic&lt;/h2>
&lt;p>Once you have found the name of the topic you want to read, either by searching the list of topics or auto-completing in the terminal, you can run &lt;code>prm explain &amp;lt;name&amp;gt;&lt;/code> to display it.&lt;/p>
&lt;p>For example, to read this documentation:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">prm explain explain-subsystem
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Which will render this document to your terminal with syntax highlighting.&lt;/p>
&lt;h2 id="documentation-versions">Documentation Versions&lt;/h2>
&lt;p>The version of the documentation available in the terminal is always the documents as they existed when that version was shipped.
For updated docs, you will need to read the documentation online, either in &lt;a href="https://github.com/puppetlabs/prm/tree/main/docs/md/content">Github&lt;/a> or on our &lt;a href="https://puppetlabs.github.io/devx/prm/">docs site&lt;/a>.&lt;/p></description></item><item><title>Docs: Writing Templates</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/usage/templates-writing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/usage/templates-writing/</guid><description>
&lt;h3 id="structure">Structure&lt;/h3>
&lt;p>A PCT is an archive containing a templated set of files and folders that represent a completed set of content. Files and folders stored in the template aren&amp;rsquo;t limited to formal Puppet project types. Source files and folders may consist of any content that you wish to create when the template is used, even if the template engine produces just one file as its output.&lt;/p>
&lt;h3 id="location">Location&lt;/h3>
&lt;p>You can specify the location of your templates using the &lt;code>--templatepath&lt;/code> option:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pct new my-name/my-custom-project --templatepath /home/me/templates
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="composition">Composition&lt;/h3>
&lt;p>A PCT must contain a &lt;code>pct-config.yml&lt;/code> in the root directory, alongside a &lt;code>content&lt;/code> directory.&lt;/p>
&lt;p>The &lt;code>content&lt;/code> directory contains the files and folders required to produce the &lt;code>project&lt;/code> or &lt;code>item&lt;/code>.&lt;/p>
&lt;p>To mark a file as a template, use the &lt;code>.tmpl&lt;/code> extension. Templated files can also use the global variable of &lt;code>{{pct_name}}&lt;/code> to access the input from the &lt;code>--name&lt;/code> cli argument.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong>
Folders within the &lt;code>content&lt;/code> directory can also use the &lt;code>{{pct_name}}&lt;/code> variable.&lt;/p>
&lt;/blockquote>
&lt;p>Example template file names:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">myConfig.json.tmpl
&lt;span style="color:#ff79c6">{{&lt;/span>pct_name&lt;span style="color:#ff79c6">}}&lt;/span>_spec.rb
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong>
One, all or none of the files can be templated.&lt;/p>
&lt;/blockquote>
&lt;h4 id="pct-configyml">pct-config.yml&lt;/h4>
&lt;p>Format of pct-config.yml&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">---
&lt;span style="color:#ff79c6">template&lt;/span>:
&lt;span style="color:#ff79c6">id&lt;/span>: &amp;lt;a unique name&amp;gt;
&lt;span style="color:#ff79c6">author&lt;/span>: &amp;lt;name|username|orgname|handle|etc&amp;gt;
&lt;span style="color:#ff79c6">type&lt;/span>: &amp;lt;&amp;#39;item&amp;#39; or &amp;#39;project&amp;#39;&amp;gt;
&lt;span style="color:#ff79c6">display&lt;/span>: &amp;lt;a human readable name&amp;gt;
&lt;span style="color:#ff79c6">version&lt;/span>: &amp;lt;semver&amp;gt;
&lt;span style="color:#ff79c6">url&lt;/span>: &amp;lt;url to project repo&amp;gt;
&amp;lt;template parameters&amp;gt;
&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong>
Template &lt;code>id&lt;/code> and &lt;code>author&lt;/code> must not contain spaces or special characters.
We recommend using a hyphen to break up the identifier.&lt;/p>
&lt;/blockquote>
&lt;p>Example pct-config.yml:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">---
&lt;span style="color:#ff79c6">template&lt;/span>:
&lt;span style="color:#ff79c6">id&lt;/span>: example-template
&lt;span style="color:#ff79c6">author&lt;/span>: myorgname
&lt;span style="color:#ff79c6">type&lt;/span>: project
&lt;span style="color:#ff79c6">display&lt;/span>: Example
&lt;span style="color:#ff79c6">version&lt;/span>: &lt;span style="color:#bd93f9">0.1.0&lt;/span>
&lt;span style="color:#ff79c6">url&lt;/span>: https://github.com/puppetlabs/example-template
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Example structure for &lt;code>example-template&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&amp;gt; tree ~/templates/example-template
/Users/me/templates/example-template
├── content
│ └── example.txt.tmpl
└── pct-config.yml
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="templating-language">Templating Language&lt;/h3>
&lt;p>PCT uses &lt;a href="https://golang.org/pkg/text/template/#hdr-Actions">Go&amp;rsquo;s templating language&lt;/a>.&lt;/p>
&lt;p>Example pct-config.yml with parameters:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">---
&lt;span style="color:#ff79c6">template&lt;/span>:
&lt;span style="color:#ff79c6">id&lt;/span>: example-template-with-params
&lt;span style="color:#ff79c6">author&lt;/span>: myorgname
&lt;span style="color:#ff79c6">type&lt;/span>: project
&lt;span style="color:#ff79c6">display&lt;/span>: Example with Parameters
&lt;span style="color:#ff79c6">version&lt;/span>: &lt;span style="color:#bd93f9">0.1.0&lt;/span>
&lt;span style="color:#ff79c6">url&lt;/span>: https://github.com/puppetlabs/pct-example-with-params
&lt;span style="color:#ff79c6">example_params&lt;/span>:
&lt;span style="color:#ff79c6">foo&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;bar&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">isPuppet&lt;/span>: &lt;span style="color:#ff79c6">true&lt;/span>
&lt;span style="color:#ff79c6">colours&lt;/span>:
- &lt;span style="color:#f1fa8c">&amp;#34;Red&amp;#34;&lt;/span>
- &lt;span style="color:#f1fa8c">&amp;#34;Blue&amp;#34;&lt;/span>
- &lt;span style="color:#f1fa8c">&amp;#34;Green&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the above template &lt;code>example-template-with-params&lt;/code> the parameters can be accessed in a &lt;code>.tmpl&lt;/code> file like so:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">{{.example_params.foo}}
{{.example_params.isPuppet}}
{{.example_params.colours}}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>outputs:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-text" data-lang="text">bar
&amp;lt;no value&amp;gt;
[Red Blue Green]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As a template author you can chose your own parameters and parameter structure so long as it is &lt;a href="https://yaml.org/spec/1.2/spec.html">valid YAML&lt;/a>. Then utilise the GO templating language to display or iterate over these.&lt;/p>
&lt;p>For most templates, we believe that you can do most of the things you would want with these common template controls:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#6272a4">// Outputs the value of `foo` defined within pct.yml
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>{{.example_template.foo}}
&lt;span style="color:#6272a4">// A conditional
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>{{&lt;span style="color:#ff79c6">if&lt;/span> .example_template.isPuppet}}
&lt;span style="color:#f1fa8c">&amp;#34;boo :(&amp;#34;&lt;/span>
{{&lt;span style="color:#ff79c6">else&lt;/span>}}
&lt;span style="color:#f1fa8c">&amp;#34;yay!&amp;#34;&lt;/span>
{{end}}
&lt;span style="color:#6272a4">// Loops over all &amp;#34;colours&amp;#34; and renders each using {{.}}
&lt;/span>&lt;span style="color:#6272a4">&lt;/span>{{&lt;span style="color:#ff79c6">range&lt;/span> .example_template.colours}} {{.}} {{end}}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>For more examples look at the existing templates provided in the &lt;strong>Default Template Location&lt;/strong>.&lt;/p>
&lt;h3 id="dos-and-donts">Dos and Don&amp;rsquo;ts&lt;/h3>
&lt;ul>
&lt;li>&lt;code>project&lt;/code> templates should provide all the code necessary to create a project from scratch and no more.&lt;/li>
&lt;li>Do not include configuration files that can be added via an &lt;code>item&lt;/code> template later by an end user, for example, CI job configuration.&lt;/li>
&lt;li>Templates should be self documenting to help guide new users on how to use the file that has been created.&lt;/li>
&lt;/ul></description></item><item><title>Docs: About PCT</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/about/</guid><description>
&lt;h2 id="overview">Overview&lt;/h2>
&lt;p>Puppet Content Templates (PCT) codify a structure to produce content for any Puppet Product that can be authored by Puppet Product Teams or external users without direct help of the PDK team.&lt;/p>
&lt;p>PCT can create any type of a Puppet Product project: Puppet control repo, Puppet Module, Bolt project, etc. It can create one or more independent files, such as CI files or gitignores. This can be as simple as a name for a Puppet Class, a set of CI files to add to a Puppet Module, or as complex as a complete Puppet Control repo with roles and profiles.&lt;/p>
&lt;p>These are meant to be ready-to-run, which means they put everything needed for a user to run the project from the moment after creation. This solves the &amp;lsquo;blank page&amp;rsquo; problem, where a few files are in place but the user does not know what the next steps are.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong>
PCT is currently in an EXPERIMENTAL phase and feedback is encouraged via &lt;a href="https://github.com/puppetlabs/pct/discussions">pct/discussions&lt;/a> and starting a &lt;code>feedback&lt;/code> post.&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Acceptance tests</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/testing/running-acceptance-tests/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/testing/running-acceptance-tests/</guid><description>
&lt;p>The following example walks you through running an acceptance test on the &lt;a href="https://github.com/puppetlabs/puppetlabs-motd">MoTD&lt;/a> module.&lt;/p>
&lt;p>The process involves these steps:&lt;/p>
&lt;ol>
&lt;li>Clone the MoTD module from GitHub.&lt;/li>
&lt;li>Provision a CentOS Docker image.&lt;/li>
&lt;li>Install a Puppet 6 agent on the CentOS image.&lt;/li>
&lt;li>Install the MoTD module on the CentOS image.&lt;/li>
&lt;li>Run the MoTD acceptance tests.&lt;/li>
&lt;li>Remove the Docker image.&lt;/li>
&lt;/ol>
&lt;h2 id="before-you-begin">Before you begin&lt;/h2>
&lt;p>Ensure you have installed the following:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://runnable.com/docker/getting-started/">Docker&lt;/a>.
&lt;ul>
&lt;li>To check whether you already have Docker, run &lt;code>docker --version&lt;/code> from the command line.&lt;/li>
&lt;li>To check Docker is working, run &lt;code>docker run centos:7 ls&lt;/code> in your terminal. You should see a list of folders in the CentOS image.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">Git&lt;/a>
&lt;ul>
&lt;li>To check where you already have git, run &lt;code>git --version&lt;/code> in your terminal.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://puppet.com/docs/pdk/1.x/pdk_install.html">Puppet Development Kit (PDK)&lt;/a>.
&lt;ul>
&lt;li>To check whether you already have PDK, run &lt;code>pdk --version&lt;/code> from the command line. Note that you need version &lt;code>1.17.0&lt;/code> or later. If not, then following the &lt;a href="https://puppet.com/docs/pdk/1.x/pdk_install.html">installation instructions&lt;/a>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="1-clone-the-motd-module-from-github">1. Clone the MoTD module from GitHub.&lt;/h2>
&lt;p>From the command line, clone the Litmus branch of MoTD module:&lt;/p>
&lt;pre>&lt;code>git clone https://github.com/puppetlabs/puppetlabs-motd.git
&lt;/code>&lt;/pre>&lt;p>You now have a local copy of the module on your machine. In this example, you can work off the master branch.&lt;/p>
&lt;p>Change directory to the MoTD module&lt;/p>
&lt;pre>&lt;code>cd puppetlabs-motd
&lt;/code>&lt;/pre>&lt;h2 id="2-install-the-necessary-gems">2. Install the necessary gems.&lt;/h2>
&lt;p>The MoTD module relies on a number of gems. To install these on your machine, run the following command:&lt;/p>
&lt;pre>&lt;code>pdk bundle install
&lt;/code>&lt;/pre>&lt;h2 id="3-provision-a-centos-docker-image">3. Provision a CentOS Docker image.&lt;/h2>
&lt;p>Provision a CentOS 7 image in a Docker container to be the target you will test against&lt;/p>
&lt;p>To provision the CentOS 7 target (or any OS of your choice), run the following command:&lt;/p>
&lt;pre>&lt;code>pdk bundle exec rake 'litmus:provision[docker, litmusimage/centos:7]'
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>Note: Provisioning is extensible. If your preferred provisioner is missing, let us know by raising an issue on the &lt;a href="https://github.com/puppetlabs/provision/issues">provision repo&lt;/a> or submitting a &lt;a href="https://github.com/puppetlabs/provision/pulls">PR&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;p>The last lines of the output should look like:&lt;/p>
&lt;pre>&lt;code>Provisioning centos:7 using docker provisioner.[✔]
localhost:2222, centos:7
&lt;/code>&lt;/pre>&lt;p>To check that it worked, run &lt;code>docker ps&lt;/code> and you should see output similar to:&lt;/p>
&lt;pre>&lt;code>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
7b12b616cf65 centos:7 &amp;quot;/bin/bash&amp;quot; 4 minutes ago Up 4 minutes 0.0.0.0:2222-&amp;gt;22/tcp centos_7-2222
&lt;/code>&lt;/pre>&lt;p>Note that the provisioned targets will be in the &lt;code>spec/fixtures/litmus_inventory.yaml&lt;/code> file. Litmus creates this file in your working directory. If you run &lt;code>cat spec/fixtures/litmus_inventory.yaml&lt;/code>, you should see the targets you just created. For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#6272a4"># litmus_inventory.yaml&lt;/span>
---
&lt;span style="color:#ff79c6">version&lt;/span>: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;span style="color:#ff79c6">groups&lt;/span>:
- &lt;span style="color:#ff79c6">name&lt;/span>: docker_nodes
&lt;span style="color:#ff79c6">targets&lt;/span>: []
- &lt;span style="color:#ff79c6">name&lt;/span>: ssh_nodes
&lt;span style="color:#ff79c6">targets&lt;/span>:
- &lt;span style="color:#ff79c6">uri&lt;/span>: localhost:2222
&lt;span style="color:#ff79c6">config&lt;/span>:
&lt;span style="color:#ff79c6">transport&lt;/span>: ssh
&lt;span style="color:#ff79c6">ssh&lt;/span>:
&lt;span style="color:#ff79c6">user&lt;/span>: root
&lt;span style="color:#ff79c6">password&lt;/span>: root
&lt;span style="color:#ff79c6">port&lt;/span>: &lt;span style="color:#bd93f9">2222&lt;/span>
&lt;span style="color:#ff79c6">host-key-check&lt;/span>: &lt;span style="color:#ff79c6">false&lt;/span>
&lt;span style="color:#ff79c6">facts&lt;/span>:
&lt;span style="color:#ff79c6">provisioner&lt;/span>: docker
&lt;span style="color:#ff79c6">container_name&lt;/span>: centos_7-2222
&lt;span style="color:#ff79c6">platform&lt;/span>: centos:7
- &lt;span style="color:#ff79c6">name&lt;/span>: winrm_nodes
&lt;span style="color:#ff79c6">targets&lt;/span>: []
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-install-puppet-agent-on-your-target">4. Install Puppet agent on your target&lt;/h2>
&lt;p>To install the latest version of Puppet agent on the CentOS Docker image, run the following command:&lt;/p>
&lt;pre>&lt;code>pdk bundle exec rake litmus:install_agent
&lt;/code>&lt;/pre>&lt;p>Use Bolt to verify that you have installed the agent on the target. Run the following command:&lt;/p>
&lt;pre>&lt;code>pdk bundle exec bolt command run 'puppet --version' --targets localhost:2222 --inventoryfile spec/fixtures/litmus_inventory.yaml
&lt;/code>&lt;/pre>&lt;p>Note that &lt;code>localhost:2222&lt;/code> is the name of the node in the spec/fixtures/litmus_inventory.yaml file. You should see output with the version of the Puppet agent that was installed:&lt;/p>
&lt;pre>&lt;code>bolt command run 'puppet --version' --targets localhost:2222 --inventoryfile spec/fixtures/litmus_inventory.yaml
&lt;/code>&lt;/pre>&lt;p>Running the command will produce output similar to this:&lt;/p>
&lt;pre>&lt;code>Started on localhost:2222...
Finished on localhost:2222:
STDOUT:
6.13.0
Successful on 1 target: localhost:2222
Ran on 1 target in 1.72 sec
&lt;/code>&lt;/pre>&lt;p>If you want to install a specific version of puppet you can use the following command:&lt;/p>
&lt;pre>&lt;code>pdk bundle exec rake 'litmus:install_agent[puppet6]
&lt;/code>&lt;/pre>&lt;p>Examples of other versions you can pass in are: puppet6-nightly, puppet7, puppet7-nightly.&lt;/p>
&lt;h2 id="5-install-the-motd-module-on-the-centos-image">5. Install the MoTD module on the CentOS image.&lt;/h2>
&lt;p>To install the MoTD module on the CentOS image, run the following command from inside your working directory:&lt;/p>
&lt;pre>&lt;code>pdk bundle exec rake litmus:install_module
&lt;/code>&lt;/pre>&lt;p>&lt;em>Note: If you are interactively modifying code and testing, this step must be run after your changes are made and before you run your tests.&lt;/em>&lt;/p>
&lt;p>You will see output similar to:&lt;/p>
&lt;pre>&lt;code>➜ puppetlabs-motd git:(main) pdk bundle exec rake litmus:install_module
pdk (INFO): Using Ruby 2.6.3
pdk (INFO): Using Puppet 7.7.0
Building '/Users/paula/workspace/puppetlabs-mysql' into '/Users/paula/workspace/puppetlabs-motd/pkg'
Built '/Users/paula/workspace/puppetlabs-motd/pkg/puppetlabs-motd-11.0.3.tar.gz'
Installed '/Users/paula/workspace/puppetlabs-motd/pkg/puppetlabs-motd-11.0.3.tar.gz' on
&lt;/code>&lt;/pre>&lt;p>Use Bolt to verify that you have installed the MoTD module. Run the following command:&lt;/p>
&lt;pre>&lt;code>pdk bundle exec bolt command run 'puppet module list' --targets localhost:2222 -i spec/fixtures/litmus_inventory.yaml
&lt;/code>&lt;/pre>&lt;p>The output should look similar to:&lt;/p>
&lt;pre>&lt;code>Started on localhost...
Finished on localhost:
STDOUT:
/etc/puppetlabs/code/environments/production/modules
├── puppetlabs-motd (v2.1.2)
├── puppetlabs-registry (v2.1.0)
├── puppetlabs-stdlib (v5.2.0)
└── puppetlabs-translate (v1.2.0)
/etc/puppetlabs/code/modules (no modules installed)
/opt/puppetlabs/puppet/modules (no modules installed)
Successful on 1 node: localhost:2222
Ran on 1 node in 1.11 seconds
Started on localhost:2222...
Finished on localhost:2222:
STDOUT:
/etc/puppetlabs/code/environments/production/modules
├── puppetlabs-motd (v4.1.0)
├── puppetlabs-registry (v3.1.0)
├── puppetlabs-stdlib (v6.2.0)
└── puppetlabs-translate (v2.1.0)
/etc/puppetlabs/code/modules (no modules installed)
/opt/puppetlabs/puppet/modules (no modules installed)
Successful on 1 target: localhost:2222
Ran on 1 target in 1.77 sec
&lt;/code>&lt;/pre>&lt;p>Note that you have also installed the MoTD module&amp;rsquo;s dependent modules.&lt;/p>
&lt;h2 id="6-run-the-motd-acceptance-tests">6. Run the MoTD acceptance tests&lt;/h2>
&lt;p>To run acceptance tests with Litmus, run the following command from your working directory:&lt;/p>
&lt;pre>&lt;code>pdk bundle exec rake litmus:acceptance:parallel
&lt;/code>&lt;/pre>&lt;p>This command executes the acceptance tests in the &lt;a href="https://github.com/puppetlabs/puppetlabs-motd/tree/main/spec/acceptance">acceptance folder&lt;/a> of the module. If the tests have run successfully, you will see output similar to (Note it will look like it has stalled but is actually running tests in the background, please be patient and the output will appear when the tests are complete:&lt;/p>
&lt;pre>&lt;code>+ [✔] Running against 1 targets.
|__ [✔] localhost:2222, centos:7
================
localhost:2222, centos:7
......
Finished in 42.95 seconds (files took 10.15 seconds to load)
6 examples, 0 failures
pid 1476 exit 0
Successful on 1 nodes: [&amp;quot;localhost:2222, centos:7&amp;quot;]
&lt;/code>&lt;/pre>&lt;h2 id="7-remove-the-docker-image">7. Remove the Docker image.&lt;/h2>
&lt;p>Now that you have completed your tests, you can remove the Docker image with the Litmus tear down command:&lt;/p>
&lt;pre>&lt;code>pdk bundle exec rake litmus:tear_down
&lt;/code>&lt;/pre>&lt;p>You should see JSON output, similar to:&lt;/p>
&lt;pre>&lt;code>localhost:2222: success
&lt;/code>&lt;/pre>&lt;p>To verify that the target has been removed, run &lt;code>docker ps&lt;/code> from the command line. You should see that it&amp;rsquo;s no longer running.&lt;/p>
&lt;h2 id="next-steps">Next steps&lt;/h2>
&lt;p>The MoTD shows you how to use Litmus to acceptance test an existing module. As you scale up your acceptance testing, you will need to write your own acceptance tests. Try out the following:&lt;/p>
&lt;ul>
&lt;li>Provision more than one system, for example, &lt;code>pdk bundle exec rake 'litmus:provision[docker, centos:6]'&lt;/code>. Note that you will need to re-run the &lt;code>install_agent&lt;/code> and &lt;code>install_module&lt;/code> command if you want to run tests.&lt;/li>
&lt;li>Look at the inventory file and take note of the ssh connection information&lt;/li>
&lt;li>ssh into the CentOS box when you know the password, for example, &lt;code>ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@localhost -p 2222&lt;/code>, or use Bolt as shown in the example.&lt;/li>
&lt;li>ssh into the CentOS box without a password, run &lt;code>docker ps&lt;/code>, take note of the Container Name and then run &lt;code>docker exec -it litmusimage_centos_7-2222 '/bin/bash'&lt;/code> in this example litmusimage_centos_7-2222 is the Container Name.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Note: We have moved all our PR testing to public pipelines to make contributing to Puppet supported modules a better experience. Check out our &lt;a href="https://github.com/puppetlabs/puppetlabs-apache/pull/2141">PR testing matrix&lt;/a> Github Actions. All of our testing is now ran in the one place.&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Command reference</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/commands/command-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/commands/command-reference/</guid><description>
&lt;h3 id="debug">Debug&lt;/h3>
&lt;p>Litmus has the ability to display more information when it is running, this can help you diagnose some issues.&lt;/p>
&lt;pre>&lt;code>export DEBUG=true
&lt;/code>&lt;/pre>&lt;h3 id="useful-docker-commands">Useful Docker commands&lt;/h3>
&lt;p>To list all docker images, including stopped ones, run:&lt;/p>
&lt;pre>&lt;code>docker ps -a
&lt;/code>&lt;/pre>&lt;p>You will get output similar to:&lt;/p>
&lt;pre>&lt;code>docker container ls -a
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
e7bc7e5b3d9b litmusimage/oraclelinux7 &amp;quot;/bin/sh -c /usr/sbi…&amp;quot; About a minute ago Up About a minute 0.0.0.0:2225-&amp;gt;22/tcp litmusimage_oraclelinux7_-2225
ae94def06077 litmusimage/oraclelinux6 &amp;quot;/bin/sh -c /sbin/in…&amp;quot; 3 minutes ago Up 3 minutes 0.0.0.0:2224-&amp;gt;22/tcp litmusimage_oraclelinux6_-2224
80b22735494e litmusimage/centos6 &amp;quot;/bin/sh -c /sbin/in…&amp;quot; 5 minutes ago Up 5 minutes 0.0.0.0:2223-&amp;gt;22/tcp litmusimage_centos6_-2223
b7923a25f95b ubuntu:14.04 &amp;quot;/bin/bash&amp;quot; 6 weeks ago Exited (255) 4 weeks ago 0.0.0.0:2222-&amp;gt;22/tcp ubuntu_14.04-2222
&lt;/code>&lt;/pre>&lt;p>To stop and remove an image, run:&lt;/p>
&lt;pre>&lt;code>docker rm -f ubuntu_14.04-2222
&lt;/code>&lt;/pre>&lt;p>To connect via ssh to the Docker image, run:&lt;/p>
&lt;pre>&lt;code>ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no root@localhost -p 2222
&lt;/code>&lt;/pre>&lt;p>Note that you don&amp;rsquo;t need to add to the known hosts file or check keys.&lt;/p>
&lt;p>To attach to the docker image and detach, run:&lt;/p>
&lt;pre>&lt;code>docker attach centos6
to deattach &amp;lt;ctrl + p&amp;gt; then &amp;lt;ctrl + q&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Note that you cannot attach to a Docker image that is running systemd/upstart, for example, the &lt;code>litmus_image&lt;/code> images.&lt;/p></description></item><item><title>Docs: Concepts</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/litmus-concepts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/litmus-concepts/</guid><description>
&lt;p>The main engineering goal of Litmus is to re-use as much existing content and external code as is feasible.
Smaller re-usable components and leveraging functionality of other projects allows for easier adaptation and allows Litmus to ride along on the success of others, like bolt.
It also means that it is easier to replace the parts that did not turn out to fulfill the needs of the users.&lt;/p>
&lt;h2 id="components">Components&lt;/h2>
&lt;p>The following list is the current set of components and implementation choices. Some of those choices are pure expediency to get something working. Others clear strategic decisions to build a better-together story.&lt;/p>
&lt;ul>
&lt;li>UI: litmus rake tasks&lt;/li>
&lt;li>Communication Layer: bolt&lt;/li>
&lt;li>Configuration:
&lt;ul>
&lt;li>&lt;code>provision.yaml&lt;/code>&lt;/li>
&lt;li>CI job setup&lt;/li>
&lt;li>&lt;code>spec/fixtures/litmus_inventory.yaml&lt;/code>&lt;/li>
&lt;li>test dependencies: .fixtures.yml&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Test Infrastructure:
&lt;ul>
&lt;li>puppetlabs-provision module&lt;/li>
&lt;li>hypervisors: docker, vagrant, vmpooler, abs&lt;/li>
&lt;li>external provisioners: e.g. terraform&lt;/li>
&lt;li>test systems:
&lt;ul>
&lt;li>litmusimage&lt;/li>
&lt;li>upstream images&lt;/li>
&lt;li>custom images&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>utility code
&lt;ul>
&lt;li>puppetlabs-facts module&lt;/li>
&lt;li>puppetlabs-puppet_agent module&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Testing System
&lt;ul>
&lt;li>runner: RSpec&lt;/li>
&lt;li>test case definition: RSpec&lt;/li>
&lt;li>test setup:
&lt;ul>
&lt;li>a manifest string embedded in the test case&lt;/li>
&lt;li>ruby code to orchestrate a change&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>test assertion
&lt;ul>
&lt;li>serverspec&lt;/li>
&lt;li>hand-coded checks&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Packaging and delivery:
&lt;ul>
&lt;li>Litmus as gem&lt;/li>
&lt;li>Litmus as PDK component&lt;/li>
&lt;li>utility modules as git repos&lt;/li>
&lt;li>bolt as gem&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>The following sections go over the various components, their reasoning and discuss alternative options.&lt;/p>
&lt;h2 id="ui">UI&lt;/h2>
&lt;p>The current UI/UX of Litmus is implemented as a set of rake tasks in &lt;a href="https://github.com/puppetlabs/puppet_litmus/blob/master/lib/puppet_litmus/rake_tasks.rb">puppet_litmus:lib/puppet_litmus/rake_tasks.rb&lt;/a>.&lt;/p>
&lt;p>&lt;strong>Reasoning:&lt;/strong>
Rake is a ubiquitous choice of interacting with a set of connected tasks in the ruby world.
The limited option parsing capabilities push the design towards simple interactions and storing important information in configuration files.
It is very easy to get started with a project based on rake tasks, as there is a wealth of examples and tutorials on how to build rake tasks.&lt;/p>
&lt;p>&lt;strong>Alternatives:&lt;/strong>
As the Litmus workflow and configuration matures we might want to consider a dedicated CLI with more ergonomic option parsing possibilities.
This could be implemented as part of the pdk (&lt;code>pdk test acceptance&lt;/code>) or a standalone CLI tool shipped as part of the PDK.&lt;/p>
&lt;p>The VSCode plugin could provide additional UI to make running and interacting with acceptance tests directly from the IDE possible.&lt;/p>
&lt;h2 id="communication-layer">Communication Layer&lt;/h2>
&lt;p>The communications layer for litmus needs to be able to talk to all the various systems that users might want to use in testing.&lt;/p>
&lt;p>&lt;strong>Reasoning:&lt;/strong>
Bolt supports SSH, WinRM natively and allows extension to other remote protocols using Puppet&amp;rsquo;s extension points.
With Bolt being integrated into our entire product line, re-using it also for content testing is an easy choice.
Content generated for Bolt can be re-used within tests, and vice versa.
This allows users to re-use skills acquired and strenghtens Puppet&amp;rsquo;s better-together story.&lt;/p>
&lt;p>&lt;strong>Alternatives:&lt;/strong>
Bolt as communication layer touches most other components and - while having a well-defined interface - would not be easy to replace.
There is currently no reason to consider alternatives to Bolt.&lt;/p>
&lt;h2 id="configuration">Configuration&lt;/h2>
&lt;p>Configuration for Litmus currently is spread over several files.
The &lt;code>provision.yaml&lt;/code> contains various lists of platforms to target for tests.
The CI job setup (usually in &lt;code>.travis.yml&lt;/code>, &lt;code>appveyor.yml&lt;/code> or similar) contains the overall sequencing of steps for testing.
This setup is usually the same everywhere and is encoded in pdk-templates.
There are slight variations to choose the puppet version and platform combinations from &lt;code>provision.yaml&lt;/code>.&lt;/p>
&lt;p>Last but not least, transient state and roles of provisioned systems is stored in Bolt&amp;rsquo;s &lt;code>inventory.yaml&lt;/code>.
The inventory is usually managed by Litmus as an implementation detail.
In advanced scenarios users can create, add, edit, or replace the inventory in pursuit of their use cases.&lt;/p>
&lt;p>&lt;strong>Reasoning:&lt;/strong>
The current set of configurations is the absolute minimum to get Litmus working.
Most of the files are inherited from existing practices and tools.&lt;/p>
&lt;p>&lt;strong>Alternatives:&lt;/strong>
While the current set of configuration files works for now, it&amp;rsquo;s main purpose is to carry Litmus over this phase and highlight the requirements for the next iteration.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Replace scattered configuration with a &lt;a href="https://puppet.com/docs/bolt/latest/bolt_project_directories.html">Boltdir&lt;/a> that can contain all the module-specific info required&lt;/p>
&lt;ul>
&lt;li>Replace .fixtures.yml with &lt;code>Boltdir/Puppetfile&lt;/code> for unit and acceptance testing&lt;/li>
&lt;li>Investigate/implement pdk/litmus specific &lt;code>Boltdir&lt;/code> location/name to avoid colliding with production use of a Boltdir&lt;/li>
&lt;li>Get test-hiera data/config from &lt;code>Boltdir/data&lt;/code> by default&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>The current setup of (re-)writing the inventory is problematic as it deprives advanced users of safe ways to enhance the inventory to suit their needs&lt;/p>
&lt;ul>
&lt;li>Example: custom SSH key/options&lt;/li>
&lt;li>Bolt has now plugins to receive inventory information from outside sources - would this be a good way to keep dynamic litmus data out of inventory.yaml?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Find ways to pass arguments to provisioners&lt;/p>
&lt;ul>
&lt;li>Hypervisor Credentials and arguments&lt;/li>
&lt;li>bolt options (e.g custom SSH key/options)&lt;/li>
&lt;li>which parts of this are module/repo specific? which parts need to be per-user?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="test-infrastructure">Test Infrastructure&lt;/h2>
&lt;p>For full system-level testing of acceptance criteria, tests require access to systems to test.
Depending on the use-case and resources available, this test infrastructure can be accessed in a variety of ways.
There are a few necessary conditions for all those test systems:&lt;/p>
&lt;ul>
&lt;li>accessible through bolt - this allows tests to act on such a system&lt;/li>
&lt;li>initially clean - without a well-defined initial state, tests become complex, unreliable, or both&lt;/li>
&lt;li>dedicated - running tests on shared systems is inviting troubles, either by tests stepping on each other or the tests interfering with user activities or the other way around&lt;/li>
&lt;li>representative of production systems - running the tests should provide insight about expected behaviour in the real world&lt;/li>
&lt;/ul>
&lt;h3 id="what-can-be-used-as-test-infrastructure">What can be used as Test Infrastructure?&lt;/h3>
&lt;p>Throw-away VMs are the easiest way to fulfil those conditions.
Provisioned from upstream images or organisations' golden templates,
they provide a complete operating system, accurate representation of production and full isolation.
The downside of virtual machines are the high resource usage and provisioning times in the order of minutes.
You can use local VMs on your development workstation, or private and public cloud providers.&lt;/p>
&lt;p>To reduce resource usage and provisioning times docker and containers come in handy.
They deploy in seconds and achieve high packing densities with low overhead.
Best practices for container images justifiably frowns on SSH access or complete operating system services,
thus common public images are usually not representative of production on full VMs.
To avoid this limitation, &lt;a href="https://github.com/puppetlabs/litmusimage">puppetlabs/litmusimages&lt;/a> provides a set of pre-fabbed &lt;a href="https://hub.docker.com/u/litmusimage">docker images&lt;/a> that allow SSH access and have an init process running.&lt;/p>
&lt;p>In some cases, using bare metal servers or already running systems is unavoidable.&lt;/p>
&lt;h3 id="how-to-provision-test-infrastructure">How to provision Test Infrastructure&lt;/h3>
&lt;p>There are as many ways to aqcuire access to test systems as there are kinds of test systems.
By default, Litmus calls out to a provisioner task to provision or tear down systems on demand.
In the &lt;code>puppetlabs-provision&lt;/code> module, we ship a number of commonly needed provisioners for docker (with SSH), docker_exp (using bolt&amp;rsquo;s docker transport), vagrant (for local VMs) and the private cloud APIs &lt;a href="https://github.com/puppetlabs/vmpooler">VMpooler&lt;/a> and the puppet-private &lt;a href="https://github.com/puppetlabs/always-be-scheduling">ABS&lt;/a>.&lt;/p>
&lt;p>Since Litmus 0.18 the rake tasks also allow calling arbitrary tasks outside the &lt;code>provision&lt;/code> module to provision test systems. &lt;a href="https://youtu.be/8BMo9DcZ4-Q">Daniel&amp;rsquo;s terraform demo&lt;/a> shows one application of this.&lt;/p>
&lt;p>The provision task will allocate/provision/start VMs or containers of the requested platforms and add them to the &lt;code>spec/fixtures/litmus_inventory.yaml&lt;/code> file.&lt;/p>
&lt;p>Through the use of the inventory file Litmus can also consume arbitrary other systems by users supplying their own data, independently of Litmus' provision capabilities.&lt;/p>
&lt;h3 id="alternatives">Alternatives&lt;/h3>
&lt;p>There are a number of opportunities to improve today&amp;rsquo;s provision capabilities.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>image customisation:
To make images usable with litmus, some customisation and workarounds need to be applied.
Be that installing SSH (litmusimage), removing tty handling (&lt;code>fix_missing_tty_error_message&lt;/code>), configuring root access (&lt;code>docker&lt;/code> provisioner), configure sudo access (&lt;code>vagrant&lt;/code> provisioner) or installing pre-reqs to install the agent (&lt;code>wget&lt;/code>/&lt;code>curl&lt;/code>/etc).
These workarounds are distributed across different components at the moment.
Collecting all of them into the image baking process (litmusimage) would&lt;/p>
&lt;ul>
&lt;li>make the provisioning code path easier and faster&lt;/li>
&lt;li>allow users to discover litmus' requirements for custom images by inspecting the litmusimage build process&lt;/li>
&lt;li>reduce &amp;ldquo;magic&amp;rdquo; happenings when using custom images&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>move inventory manipulation from provisioning tasks to litmus:
Currently provisioning tasks are required to update the &lt;code>spec/fixtures/litmus_inventory.yaml&lt;/code> file with new target information and remove targets from the &lt;code>spec/fixtures/litmus_inventory.yaml&lt;/code> file on tear down.
This causes a number of problems:&lt;/p>
&lt;ul>
&lt;li>code duplication&lt;/li>
&lt;li>prohibits running provisioners in parallel&lt;/li>
&lt;li>unnecessarily pushes some operations (see &lt;code>vars&lt;/code> handling) into provision tasks&lt;/li>
&lt;li>requires provision tasks to run on the caller&amp;rsquo;s host
Instead of writing directly to &lt;code>spec/fixtures/litmus_inventory.yaml&lt;/code> file the provision tasks could return bolt transport configuration as part of the task result data.
Litmus could then process that data as required in the work flow.
Provisioners could now run in parallel and Litmus can coalesce the data at the end into a &lt;code>spec/fixtures/litmus_inventory.yaml&lt;/code> file.
This approach requires only minimal code in the task (return data as JSON).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>allow more granular data than the platform name:
Some provisioners could benefit from additional parameters passed in.
For example choosing a specific AWS zone, VPC, GCP project or tags to host the test systems.
This change also interacts with changes to how configuration data is stored. See &amp;lsquo;Configuration&amp;rsquo; section above.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="utility-code">Utility Code&lt;/h2>
&lt;p>Litmus makes use of the &lt;a href="https://github.com/puppetlabs/puppetlabs-facts">&lt;code>puppetlabs-facts&lt;/code>&lt;/a> and &lt;a href="https://github.com/puppetlabs/puppetlabs-puppet_agent">&lt;code>puppetlabs-puppet_agent&lt;/code>&lt;/a> modules for some key operations.&lt;/p>
&lt;p>&lt;strong>Reasoning:&lt;/strong>
These modules are maintained and used in other parts of the ecosystem already.
Reusing them provides for a consistent behaviour across different products and additional value gained from the existing development and maintenance effort.&lt;/p>
&lt;p>&lt;strong>Alternatives:&lt;/strong>
None required at the moment.&lt;/p>
&lt;p>&lt;strong>Alternatives:&lt;/strong>
None required at the moment.&lt;/p>
&lt;h2 id="testing-system">Testing System&lt;/h2>
&lt;p>This section covers all the things concerned with defining and executing the test cases.&lt;/p>
&lt;h3 id="test-runner">Test Runner&lt;/h3>
&lt;p>RSpec is a mature and widely used unit-testing framework in the Ruby Ecosystem.
We are maintaining mature integrations for Puppet catalog-level unit testing and there is a rich ecosystem of adjacent tooling by the puppet community.&lt;/p>
&lt;p>&lt;strong>Rationale:&lt;/strong>
Using an existing product keeps us from re-inventing the wheel.
RSpec has a host of already built in features and an ecosystem of plugins as well as tutorials and documentation.
We&amp;rsquo;ve been able to adapt RSpec to our needs by using existing extension points.
RSpec allows for fine-grained and dynamic test-selection, and provides excellent feedback to the user.&lt;/p>
&lt;p>&lt;strong>Alternatives:&lt;/strong>
None required at the moment.&lt;/p>
&lt;h3 id="test-case-definition">Test Case Definition&lt;/h3>
&lt;p>While RSpec&amp;rsquo;s fine-grained test setup capabilities are very necessary and useful for unit testing, the same capabilities have reduced applicability when looking at acceptance testing.
These system-level tests usually have a lot more setup requirements and fewer, but more specialised tests.&lt;/p>
&lt;p>&lt;strong>Rationale:&lt;/strong>
RSpec test case definition language was chosen by default as part of the RSpec test runner in the early stages of the evolution of Puppet test practices.&lt;/p>
&lt;p>&lt;strong>Alternatives:&lt;/strong>
For a while &lt;a href="https://github.com/petems/cucumber-puppet">cucumber-puppet&lt;/a> was developed by some as an alternative but never gained as much traction or support in the Puppet community.&lt;/p>
&lt;h3 id="test-setup">Test Setup&lt;/h3>
&lt;p>The test setup describes the necessary steps to reach the state to test.
In litmus this is currently implemented by a mix of manifest strings embedded in ruby and litmus' ruby DSL calls.&lt;/p>
&lt;p>&lt;strong>Rationale:&lt;/strong>
This style of test setup is inherited from beaker-rspec and &amp;ldquo;The RSpec Way&amp;rdquo;.&lt;/p>
&lt;p>&lt;strong>Alternatives:&lt;/strong>
Creating RSpec extensions for acceptance testing - like rspec-puppet does for unit testing - to represent common patterns would allow for crisper test setup definition.
The additional abstraction could allow for more clarity and efficiency in setting up tests.&lt;/p>
&lt;h3 id="test-assertion">Test Assertion&lt;/h3>
&lt;p>After a test scenario is set up, assertions are executed to understand whether or not the original expectations are met.
This can be as simple as checking a file&amp;rsquo;s content to as complex as interacting with an API to check its behaviour.&lt;/p>
&lt;p>In acceptance tests the first way to check a system&amp;rsquo;s target state is idempotency.
This is implemented as first-class operation &lt;code>idempotent_apply&lt;/code> in the Litmus DSL.&lt;/p>
&lt;p>To ascertain that a service is not only working, but also correctly configured more in-depth checks need to be implemented in ruby.
&lt;a href="https://serverspec.org/">serverspec&lt;/a> is preconfigured inside Litmus to allow for checking a number of common resources.&lt;/p>
&lt;p>Other checks can be implemented in plain ruby or RSpec as required.&lt;/p>
&lt;h4 id="rationale">Rationale&lt;/h4>
&lt;p>Tests derive value from being easier to understand than the code under test. Through this they provide a confidence that merely reading the business logic (or, in Litmus' case the manifest) does not support.&lt;/p>
&lt;p>If puppet runs the same manifest a second time without errors or changes, this already implies that the desired system state has been reached.
In many cases - for example when managing services - this is a more in-depth check that a test could do on its own.
A service starting up and staying running implies that its configuration was valid and consistent.
This is a check that would be very hard, nay prohibitively expensive, to implement in a test.
Idempotency checking makes this (almost) free.&lt;/p>
&lt;p>Serverspec was created for acceptance testing infrastructure.
It integrates nicely with RSpec.
Serverspec provides &lt;a href="https://serverspec.org/resource_types.html">resources and checks&lt;/a> that are currently not expressible in puppet code, like &amp;ldquo;port should be listening&amp;rdquo; or partial matching on file contents.&lt;/p>
&lt;h4 id="alternatives-1">Alternatives&lt;/h4>
&lt;ul>
&lt;li>&lt;a href="https://www.inspec.io/">Chef&amp;rsquo;s InSpec&lt;/a> was forked from serverspec and developed by Chef.&lt;/li>
&lt;li>&lt;a href="https://www.selenium.dev/">Selenium&lt;/a> automates browsers and arguably could be used to check the health of a service deployed for testing.&lt;/li>
&lt;li>Any kind of monitoring or application-level testing framework that is already used for a specific service could be used to create insight into the health of said service.&lt;/li>
&lt;/ul>
&lt;h2 id="packaging-and-delivery">Packaging and Delivery&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Litmus is currently released as a gem first.&lt;/p>
&lt;p>&lt;strong>Rationale:&lt;/strong>
In this phase of development this allows for rapid iteration.
Deploying gems is well-understood in the development community.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Litmus is also shipped as part of the PDK.&lt;/p>
&lt;p>&lt;strong>Rationale:&lt;/strong>
As an experimental part of the PDK Litmus becomes available offline to those who otherwise would need to cross air-gaps.
At the same time, this also ensures that all the required dependencies are available in a PDK installation.
Specifically this also would notify us if Litmus adds a dependency that is not compatible with the PDK runtime.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The Utility Modules are currently by default deployed into a test run directly from github.&lt;/p>
&lt;p>&lt;strong>Rationale:&lt;/strong>
Expediency and speed.&lt;/p>
&lt;p>&lt;strong>Alternatives:&lt;/strong>
To avoid poisoning test environments with litmus' implementation details and better support offline work,
the utility modules should be packaged up as part of the litmus gem and sourced from a private modulepath when needed.
Grouping all content in that way enhances confidence that it is a fully tested package.
This would also require more integrated testing and more frequent litmus releases to make changes available.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bolt is currently consumed as a gem&lt;/p>
&lt;p>&lt;strong>Rationale:&lt;/strong>
Litmus is tightly bound to specific internal APIs and its dependencies.
Depending on a gem provides flexibility in consuming bolt updates as Litmus is ready for it.
Using the gem avoids any environmental dependencies and support issues arising from version mismatches.&lt;/p>
&lt;p>&lt;strong>Alternatives:&lt;/strong>
Require bolt to be installed from its package.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Contact DevX about PCT</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/contact/contact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/contact/contact/</guid><description>
&lt;h2 id="requesting-a-feature">Requesting a feature&lt;/h2>
&lt;p>Open a new feature request in our &lt;a href="https://github.com/puppetlabs/pct/issues/new">Github discussion&lt;/a> page.&lt;/p>
&lt;h2 id="reporting-problems">Reporting Problems&lt;/h2>
&lt;p>If you&amp;rsquo;re having trouble with the experimental PCT tool, please follow these instructions
to file an issue on our GitHub repository: &lt;a href="https://github.com/puppetlabs/pct/issues/new">https://github.com/puppetlabs/pct/issues/new&lt;/a>&lt;/p>
&lt;p>Make sure to fill in the information that is requested in the issue template as it
will help us investigate the problem more quickly.&lt;/p></description></item><item><title>Docs: Core commands</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/commands/litmus-core-commands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/commands/litmus-core-commands/</guid><description>
&lt;p>Using the Litmus commands, you can provision test platforms such as containers/images, install a Puppet agent, install a module and run tests.&lt;/p>
&lt;p>Litmus has five commands:&lt;/p>
&lt;ol>
&lt;li>&lt;a href="#provision">Provision: &amp;lsquo;rake litmus:provision&amp;rsquo;&lt;/a>&lt;/li>
&lt;li>&lt;a href="#agent">Install the agent: &amp;lsquo;rake litmus:install_agent&lt;/a>&lt;/li>
&lt;li>&lt;a href="#module">Install the module: &amp;lsquo;rake litmus:install_module&amp;rsquo;&lt;/a>&lt;/li>
&lt;li>&lt;a href="#test">Run the tests: &amp;lsquo;rake litmus:acceptance:parallel&amp;rsquo;&lt;/a>&lt;/li>
&lt;li>&lt;a href="#teardown">Remove the provisioned machines: &amp;lsquo;rake litmus:tear_down&amp;rsquo;&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>These commands allow you to create a test environment and run tests against your systems. Note that not all of these steps are needed for every deployment.&lt;/p>
&lt;p>Three common test setups are:&lt;/p>
&lt;ul>
&lt;li>Run against localhost&lt;/li>
&lt;li>Run against an existing machine that has Puppet installed&lt;/li>
&lt;li>Provision a fresh system and install Puppet&lt;/li>
&lt;/ul>
&lt;p>Once you have your environment, Litmus is designed to speed up the following workflow:&lt;/p>
&lt;pre>&lt;code>edit code -&amp;gt; install module -&amp;gt; run test
&lt;/code>&lt;/pre>&lt;p>At any point you can re-run tests, or provision new systems and add them to your test environment.&lt;/p>
&lt;a name="provision"/>
&lt;h2 id="provisioning">Provisioning&lt;/h2>
&lt;p>Using the Litmus &lt;a href="https://github.com/puppetlabs/provision">provision&lt;/a> command, you can spin up Docker containers, vagrant boxes or VMs in private clouds, such as vmpooler.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;pre>&lt;code>pdk bundle exec rake 'litmus:provision[vmpooler, redhat-6-x86_64]'
pdk bundle exec rake 'litmus:provision[docker, litmusimage/ubuntu:18.04]'
pdk bundle exec rake 'litmus:provision[vagrant, gusztavvargadr/windows-server]'
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>Note: Provisioning is extensible — if your chosen provisioner isn&amp;rsquo;t available, you can add your own provisioner task to your test set up through a separate module in &lt;code>.fixtures.yml&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;p>The provision command creates a Bolt &lt;code>spec/fixtures/litmus_inventory.yml&lt;/code> file for Litmus to use. You can manually add machines to this file.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">---
&lt;span style="color:#ff79c6">version&lt;/span>: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;span style="color:#ff79c6">groups&lt;/span>:
- &lt;span style="color:#ff79c6">name&lt;/span>: docker_nodes
&lt;span style="color:#ff79c6">targets&lt;/span>: []
- &lt;span style="color:#ff79c6">name&lt;/span>: ssh_nodes
&lt;span style="color:#ff79c6">targets&lt;/span>:
- &lt;span style="color:#ff79c6">uri&lt;/span>: localhost:2222
&lt;span style="color:#ff79c6">config&lt;/span>:
&lt;span style="color:#ff79c6">transport&lt;/span>: ssh
&lt;span style="color:#ff79c6">ssh&lt;/span>:
&lt;span style="color:#ff79c6">user&lt;/span>: root
&lt;span style="color:#ff79c6">password&lt;/span>: root
&lt;span style="color:#ff79c6">port&lt;/span>: &lt;span style="color:#bd93f9">2222&lt;/span>
&lt;span style="color:#ff79c6">host-key-check&lt;/span>: &lt;span style="color:#ff79c6">false&lt;/span>
&lt;span style="color:#ff79c6">facts&lt;/span>:
&lt;span style="color:#ff79c6">provisioner&lt;/span>: docker
&lt;span style="color:#ff79c6">container_name&lt;/span>: centos_7-2222
&lt;span style="color:#ff79c6">platform&lt;/span>: centos:7
- &lt;span style="color:#ff79c6">name&lt;/span>: winrm_nodes
&lt;span style="color:#ff79c6">targets&lt;/span>: []
&lt;/code>&lt;/pre>&lt;/div>&lt;p>For more examples of inventory files, see the &lt;a href="https://puppet.com/docs/bolt/latest/inventory_file_v2.html">Bolt documentation&lt;/a>.&lt;/p>
&lt;p>Note that you can test some modules against localhost — the machine you are running your test from. Note that this is only recommended if you are familiar with the code base, as tests may have unexpected side effects on your local machine. To run a test against localhost, see &lt;a href="#test">Run the tests: &amp;lsquo;rake litmus:parallel&amp;rsquo;&lt;/a>&lt;/p>
&lt;h3 id="testing-services">Testing services&lt;/h3>
&lt;p>For testing services that require a service manager (like systemd), the default Docker images might not be enough. In this case, there is a collection of Docker images, with a service manager enabled, based on &lt;a href="https://github.com/puppetlabs/litmusimage">https://github.com/puppetlabs/litmusimage&lt;/a>. For available images, see the &lt;a href="https://hub.docker.com/u/litmusimage">docker hub&lt;/a>.&lt;/p>
&lt;p>Alternatively, you can use a dedicated VM that uses another provisioner, for example vmpooler or vagrant.&lt;/p>
&lt;h3 id="provisioning-via-yaml">Provisioning via YAML&lt;/h3>
&lt;p>In addition to directly provisioning one or more machines using &lt;code>litmus:provision&lt;/code>, you can also define one or more sets of nodes in a &lt;code>provision.yaml&lt;/code> file and use that to provision targets.&lt;/p>
&lt;p>An example of a &lt;code>provision.yaml&lt;/code> defining a single node:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">---
&lt;span style="color:#ff79c6">list_name&lt;/span>:
&lt;span style="color:#ff79c6">provisioner&lt;/span>: vagrant
&lt;span style="color:#ff79c6">images&lt;/span>: [&lt;span style="color:#f1fa8c">&amp;#39;centos/7&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;generic/ubuntu1804&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;gusztavvargadr/windows-server&amp;#39;&lt;/span>]
&lt;span style="color:#ff79c6">params&lt;/span>:
&lt;span style="color:#ff79c6">param_a&lt;/span>: someone
&lt;span style="color:#ff79c6">param_b&lt;/span>: something
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Take note of the following:&lt;/p>
&lt;ul>
&lt;li>The &lt;code>list_name&lt;/code> is arbitrary and can be any string you want.&lt;/li>
&lt;li>The &lt;code>provisioner&lt;/code> specifies which provision task to use.&lt;/li>
&lt;li>The &lt;code>images&lt;/code> must specify an array of one or more images to provision.&lt;/li>
&lt;li>Any keys inside of &lt;code>params&lt;/code> will be turned into process-scope environment variables as the key, upcased. In the example above, &lt;code>param_a&lt;/code> would become an environment variable called &lt;code>PARAM_A&lt;/code> with a value of &lt;code>someone&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>An example of a &lt;code>provision.yaml&lt;/code> defining multiple nodes:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">---
---
&lt;span style="color:#ff79c6">default&lt;/span>:
&lt;span style="color:#ff79c6">provisioner&lt;/span>: docker
&lt;span style="color:#ff79c6">images&lt;/span>: [&lt;span style="color:#f1fa8c">&amp;#39;litmusimage/centos:7&amp;#39;&lt;/span>]
&lt;span style="color:#ff79c6">vagrant&lt;/span>:
&lt;span style="color:#ff79c6">provisioner&lt;/span>: vagrant
&lt;span style="color:#ff79c6">images&lt;/span>: [&lt;span style="color:#f1fa8c">&amp;#39;centos/7&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;generic/ubuntu1804&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;gusztavvargadr/windows-server&amp;#39;&lt;/span>]
&lt;span style="color:#ff79c6">docker_deb&lt;/span>:
&lt;span style="color:#ff79c6">provisioner&lt;/span>: docker
&lt;span style="color:#ff79c6">images&lt;/span>: [&lt;span style="color:#f1fa8c">&amp;#39;litmusimage/debian:8&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;litmusimage/debian:9&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;litmusimage/debian:10&amp;#39;&lt;/span>]
&lt;span style="color:#ff79c6">docker_ub&lt;/span>:
&lt;span style="color:#ff79c6">provisioner&lt;/span>: docker
&lt;span style="color:#ff79c6">images&lt;/span>: [&lt;span style="color:#f1fa8c">&amp;#39;litmusimage/ubuntu:14.04&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;litmusimage/ubuntu:16.04&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;litmusimage/ubuntu:18.04&amp;#39;&lt;/span>]
&lt;span style="color:#ff79c6">docker_el6&lt;/span>:
&lt;span style="color:#ff79c6">provisioner&lt;/span>: docker
&lt;span style="color:#ff79c6">images&lt;/span>: [&lt;span style="color:#f1fa8c">&amp;#39;litmusimage/centos:6&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;litmusimage/oraclelinux:6&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;litmusimage/scientificlinux:6&amp;#39;&lt;/span>]
&lt;span style="color:#ff79c6">docker_el7&lt;/span>:
&lt;span style="color:#ff79c6">provisioner&lt;/span>: docker
&lt;span style="color:#ff79c6">images&lt;/span>: [&lt;span style="color:#f1fa8c">&amp;#39;litmusimage/centos:7&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;litmusimage/oraclelinux:7&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;litmusimage/scientificlinux:7&amp;#39;&lt;/span>]
&lt;span style="color:#ff79c6">release_checks&lt;/span>:
&lt;span style="color:#ff79c6">provisioner&lt;/span>: vmpooler
&lt;span style="color:#ff79c6">images&lt;/span>: [&lt;span style="color:#f1fa8c">&amp;#39;redhat-5-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;redhat-6-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;redhat-7-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;redhat-8-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;centos-5-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;centos-6-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;centos-7-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;centos-8-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;oracle-5-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;oracle-6-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;oracle-7-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;scientific-6-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;scientific-7-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;debian-8-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;debian-9-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;debian-10-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;sles-11-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;sles-12-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;sles-15-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;ubuntu-1404-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;ubuntu-1604-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;ubuntu-1804-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;win-2008r2-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;win-2012r2-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;win-2016-core-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;win-2019-core-x86_64&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;win-10-pro-x86_64&amp;#39;&lt;/span>]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can then provision a list of targets from that file:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#6272a4"># This will spin up all the nodes defined in the `release_checks` key via VMPooler&lt;/span>
pdk bundle &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> rake &lt;span style="color:#f1fa8c">&amp;#39;litmus:provision_list[release_checks]&amp;#39;&lt;/span>
&lt;span style="color:#6272a4"># This will spin up the three nodes listed in the `vagrant` key via Vagrant.&lt;/span>
&lt;span style="color:#6272a4"># Note that it will also turn the listed key-value pairs in `params` into&lt;/span>
&lt;span style="color:#6272a4"># the environment variables and enable the task to leverage them.&lt;/span>
pdk bundle &lt;span style="color:#8be9fd;font-style:italic">exec&lt;/span> rake &lt;span style="color:#f1fa8c">&amp;#39;litmus:provision_list[vagrant]&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;a name="agent"/>
&lt;h2 id="installing-a-puppet-agent">Installing a Puppet agent&lt;/h2>
&lt;p>Install an agent on the provisioned targets using the &lt;a href="https://github.com/puppetlabs/puppetlabs-puppet_agent">Puppet Agent module&lt;/a>. The tasks in this module allow you to install different versions of the Puppet agent, on different OSes.&lt;/p>
&lt;p>Use the following command to install an agent on a single target or on all the targets in the &lt;code>spec/fixtures/litmus_inventory.yaml&lt;/code> file. Note that agents are installed in parallel when running against multiple targets.&lt;/p>
&lt;p>Install an agent on a target using the following commands:&lt;/p>
&lt;pre>&lt;code># Install the latest Puppet agent on a specific target
pdk bundle exec rake 'litmus:install_agent[gn55owqktvej9fp.delivery.puppetlabs.net]'
# Install the latest Puppet agent on all targets
pdk bundle exec rake &amp;quot;litmus:install_agent&amp;quot;
# Install Puppet 5 on all targets
pdk bundle exec rake 'litmus:install_agent[puppet5]'
&lt;/code>&lt;/pre>&lt;a name="module"/>
&lt;h2 id="installing-a-module">Installing a module&lt;/h2>
&lt;p>Using PDK and Bolt, the &lt;code>rake litmus:install_module&lt;/code> command builds and installs a module on the target.&lt;/p>
&lt;p>For example:&lt;/p>
&lt;pre>&lt;code>pdk bundle exec rake &amp;quot;litmus:install_module&amp;quot;
&lt;/code>&lt;/pre>&lt;p>If you need multiple modules on the target system (e.g. fixtures pulled down through &lt;code>pdk bundle exec rake spec_prep&lt;/code>, or a previous unit test run):&lt;/p>
&lt;pre>&lt;code>pdk bundle exec rake &amp;quot;litmus:install_modules_from_directory[spec/fixtures/modules]&amp;quot;
&lt;/code>&lt;/pre>&lt;a name="test"/>
&lt;h2 id="running-tests">Running tests&lt;/h2>
&lt;p>There are several options for running tests. Litmus primarily uses &lt;a href="https://serverspec.org/">serverspec&lt;/a>, though you can use other testing tools.&lt;/p>
&lt;p>When running tests with Litmus, you can:&lt;/p>
&lt;ul>
&lt;li>Run all tests against a single target.&lt;/li>
&lt;li>Run all tests against all targets in parallel.&lt;/li>
&lt;li>Run a single test against a single target.&lt;/li>
&lt;/ul>
&lt;p>An example running all tests against a single target:&lt;/p>
&lt;pre>&lt;code># On Linux/MacOS:
TARGET_HOST=lk8g530gzpjxogh.delivery.puppetlabs.net pdk bundle exec rspec ./spec/acceptance
TARGET_HOST=localhost:2223 pdk bundle exec rspec ./spec/acceptance
# On Windows:
$ENV:TARGET_HOST = 'lk8g530gzpjxogh.delivery.puppetlabs.net'
pdk bundle exec rspec ./spec/acceptance
&lt;/code>&lt;/pre>&lt;p>An example running a specific test against a single target:&lt;/p>
&lt;pre>&lt;code># On Linux/MacOS:
TARGET_HOST=lk8g530gzpjxogh.delivery.puppetlabs.net pdk bundle exec rspec ./spec/acceptance/test_spec.rb:21
TARGET_HOST=localhost:2223 pdk bundle exec rspec ./spec/acceptance/test_spec.rb:21
# On Windows:
$ENV:TARGET_HOST = 'lk8g530gzpjxogh.delivery.puppetlabs.net'
pdk bundle exec rspec ./spec/acceptance/test_spec.rb:21
&lt;/code>&lt;/pre>&lt;p>An example running all tests against all targets, as specified in the &lt;code>spec/fixtures/litmus_inventory.yaml&lt;/code> file:&lt;/p>
&lt;pre>&lt;code>pdk bundle exec rake litmus:acceptance:parallel
&lt;/code>&lt;/pre>&lt;p>An example running all tests against localhost. Note that this is only recommended if you are familiar with the code base, as tests may have unexpected side effects on your local machine.&lt;/p>
&lt;pre>&lt;code>pdk bundle exec rake litmus:acceptance:localhost
&lt;/code>&lt;/pre>&lt;p>For more test examples, see &lt;a href="https://github.com/puppetlabs/provision/wiki#run_tests">run_tests task&lt;/a> or &lt;a href="https://github.com/puppetlabs/provision/wiki#tests_against_agents">run tests plan&lt;/a>&lt;/p>
&lt;a name="teardown"/>
&lt;h2 id="removing-provisioned-systems">Removing provisioned systems&lt;/h2>
&lt;p>Use the commands below to clean up provisioned systems after running tests. Specify whether to to remove an individual target or all the targets in the &lt;code>spec/fixtures/litmus_inventory.yaml&lt;/code> file.&lt;/p>
&lt;pre>&lt;code># Tear down a specific target vm
pdk bundle exec rake &amp;quot;litmus:tear_down[c985f9svvvu95nv.delivery.puppetlabs.net]&amp;quot;
# Tear down a specific target running locally
pdk bundle exec rake &amp;quot;litmus:tear_down[localhost:2222]&amp;quot;
# Tear down all targets in `spec/fixtures/litmus_inventory.yaml` file
pdk bundle exec rake &amp;quot;litmus:tear_down&amp;quot;
&lt;/code>&lt;/pre></description></item><item><title>Docs: Example tests</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/testing/litmus-test-examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/testing/litmus-test-examples/</guid><description>
&lt;p>These are some common examples you can use in your tests. Take note of the differences between beaker-rspec style testing and Litmus.&lt;/p>
&lt;h2 id="testing-puppet-code">Testing Puppet code&lt;/h2>
&lt;p>The following example tests that your Puppet code works. Take note of the repeatable pattern.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="color:#8be9fd;font-style:italic">require&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;spec_helper_acceptance&amp;#39;&lt;/span>
describe &lt;span style="color:#f1fa8c">&amp;#39;a feature&amp;#39;&lt;/span>, &lt;span style="color:#ff79c6">if&lt;/span>: &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;debian&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;redhat&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;ubuntu&amp;#39;&lt;/span>&lt;span style="color:#ff79c6">].&lt;/span>include?(os&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#f1fa8c">:family&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>) &lt;span style="color:#ff79c6">do&lt;/span>
let(&lt;span style="color:#f1fa8c">:pp&lt;/span>) &lt;span style="color:#ff79c6">do&lt;/span>
&lt;span style="color:#f1fa8c">&amp;lt;&amp;lt;-MANIFEST
&lt;/span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#ff79c6">include&lt;/span> feature&lt;span style="color:#ff79c6">::&lt;/span>some_class
MANIFEST
&lt;span style="color:#ff79c6">end&lt;/span>
it &lt;span style="color:#f1fa8c">&amp;#39;applies idempotently&amp;#39;&lt;/span> &lt;span style="color:#ff79c6">do&lt;/span>
idempotent_apply(pp)
&lt;span style="color:#ff79c6">end&lt;/span>
describe file(&lt;span style="color:#f1fa8c">&amp;#34;/etc/feature.conf&amp;#34;&lt;/span>) &lt;span style="color:#ff79c6">do&lt;/span>
it { is_expected&lt;span style="color:#ff79c6">.&lt;/span>to be_file }
its(&lt;span style="color:#f1fa8c">:content&lt;/span>) { is_expected&lt;span style="color:#ff79c6">.&lt;/span>to match &lt;span style="color:#f1fa8c">%r{key = default value}&lt;/span> }
&lt;span style="color:#ff79c6">end&lt;/span>
describe port(&lt;span style="color:#bd93f9">777&lt;/span>) &lt;span style="color:#ff79c6">do&lt;/span>
it { is_expected&lt;span style="color:#ff79c6">.&lt;/span>to be_listening }
&lt;span style="color:#ff79c6">end&lt;/span>
&lt;span style="color:#ff79c6">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="testing-manifest-code-for-idempotency">Testing manifest code for idempotency&lt;/h2>
&lt;p>The &lt;code>idempotent_apply&lt;/code> helper function runs the given manifest twice and will test that the first run doesn&amp;rsquo;t have errors and the second run doesn&amp;rsquo;t have changes. For many regular modules that already will give good confidence that it is working:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">pp &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;class { &amp;#34;mysql::server&amp;#34;: }&amp;#39;&lt;/span>
idempotent_apply(pp)
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="running-shell-commands">Running shell commands&lt;/h2>
&lt;p>To run a shell command and test it&amp;rsquo;s output:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">expect(run_shell(&lt;span style="color:#f1fa8c">&amp;#39;/usr/local/sbin/mysqlbackup.sh&amp;#39;&lt;/span>)&lt;span style="color:#ff79c6">.&lt;/span>stderr)&lt;span style="color:#ff79c6">.&lt;/span>to eq(&lt;span style="color:#f1fa8c">&amp;#39;&amp;#39;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="serverspec-idioms">Serverspec Idioms&lt;/h3>
&lt;p>An example of a serverspec declaration:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">describe command(&lt;span style="color:#f1fa8c">&amp;#39;/usr/local/sbin/mysqlbackup.sh&amp;#39;&lt;/span>) &lt;span style="color:#ff79c6">do&lt;/span>
its(&lt;span style="color:#f1fa8c">:stderr&lt;/span>) { should eq &lt;span style="color:#f1fa8c">&amp;#39;&amp;#39;&lt;/span> }
&lt;span style="color:#ff79c6">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="checking-facts">Checking facts&lt;/h2>
&lt;p>With Litmus, you can use the serverspec functions — these are cached so are quick to call. For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">os&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#f1fa8c">:family&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>or&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">host_inventory&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;facter&amp;#39;&lt;/span>&lt;span style="color:#ff79c6">][&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;os&amp;#39;&lt;/span>&lt;span style="color:#ff79c6">][&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;release&amp;#39;&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>For more information, see the &lt;a href="https://serverspec.org/host_inventory.html">serverspec docs&lt;/a>.&lt;/p>
&lt;h2 id="debugging-tests">Debugging tests&lt;/h2>
&lt;p>There is a known issue when running certain commands from within a pry session. To debug tests, use the following pry-byebug gem:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-ruby" data-lang="ruby">gem &lt;span style="color:#f1fa8c">&amp;#39;pry-byebug&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;&amp;gt; 3.4.3&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="setting-up-travis-and-appveyor">Setting up Travis and Appveyor&lt;/h2>
&lt;p>To see this running on CI, enable the &lt;code>use_litmus&lt;/code> flags for Travis CI and/or Appveyor. See the &lt;a href="https://github.com/puppetlabs/pdk-templates#travisyml">pdk-templates docs&lt;/a> for details and additional options.&lt;/p></description></item><item><title>Docs: Helper functions</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/litmus-helper-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/litmus-helper-functions/</guid><description>
&lt;p>Inside of the Litmus gem, there are three distinct sets of functions:&lt;/p>
&lt;ul>
&lt;li>Rake tasks for the CLI that allows you to use the Litmus commands (provision, install an agent, install a module and run tests.). Run &lt;code>pdk bundle exec rake -T&lt;/code> to get a list of available rake tasks.&lt;/li>
&lt;li>Helper functions for serverspec / test. These apply manifests or run shell commands. For more information, see &lt;a href="https://www.rubydoc.info/gems/puppet_litmus/PuppetLitmus/PuppetHelpers">Puppet Helpers&lt;/a>&lt;/li>
&lt;li>Helper Functions for Bolt inventory file manipulation. For more information, see &lt;a href="https://www.rubydoc.info/gems/puppet_litmus/PuppetLitmus/InventoryManipulation">Inventory Manipulation&lt;/a>.&lt;/li>
&lt;/ul></description></item><item><title>Docs: Overriding Template Defaults</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/usage/templates-overriding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/usage/templates-overriding/</guid><description>
&lt;p>Perhaps you use a template often and find that you set the same values over and over?
As a template user, you can choose to override the default values specified by a template author.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note:&lt;/strong>
To view the default parameters for a template run &lt;code>pct new --info &amp;lt;TEMPLATE_ID&amp;gt;&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;p>To override these defaults you need to create a &lt;code>pct.yml&lt;/code> containing the template id along with the values you wish to override.&lt;/p>
&lt;p>Example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#ff79c6">example_template&lt;/span>:
&lt;span style="color:#ff79c6">foo&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;wibble&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">isPuppet&lt;/span>: &lt;span style="color:#ff79c6">false&lt;/span>
&lt;span style="color:#ff79c6">colours&lt;/span>:
- &lt;span style="color:#f1fa8c">&amp;#34;Red&amp;#34;&lt;/span>
- &lt;span style="color:#f1fa8c">&amp;#34;Blue&amp;#34;&lt;/span>
&lt;span style="color:#ff79c6">another_template&lt;/span>:
&lt;span style="color:#ff79c6">key&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;value&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You don&amp;rsquo;t need to override everything.
For example:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#ff79c6">example_template&lt;/span>:
&lt;span style="color:#ff79c6">isPuppet&lt;/span>: &lt;span style="color:#ff79c6">false&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="user-level-configuration">User level configuration&lt;/h3>
&lt;p>Placing a &lt;code>pct.yml&lt;/code> within &lt;code>$HOME/.pdk/&lt;/code> allows you to create global overrides. Everytime you generate content from a template the configuration will be used.&lt;/p>
&lt;h3 id="workspace-configuration">Workspace configuration&lt;/h3>
&lt;p>You may also place a &lt;code>pct.yml&lt;/code> within a workspace.&lt;/p>
&lt;p>Running &lt;code>pct new&lt;/code> within a directory makes the current working directory your workspace.
If you specify an &lt;code>--outputdir&lt;/code> that location is your workspace.&lt;/p>
&lt;p>The configuration specified in a workspace &lt;code>pct.yml&lt;/code> will override any configuration found within the user level configuration at &lt;code>$HOME/.pdk/pct.yml&lt;/code>&lt;/p></description></item><item><title>Docs: Sharing Templates</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/usage/templates-sharing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/pct/usage/templates-sharing/</guid><description>
&lt;p>After you&amp;rsquo;ve written your own template you may wish to share it with other members of your team or the wider Puppet community. Work is underway to improve this initial functionality.&lt;/p>
&lt;h3 id="pct-build">pct build&lt;/h3>
&lt;p>This command will attempt to package the current working directory. You can change the directory to pack by providing &lt;code>--sourcedir&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pct build &lt;span style="color:#ff79c6">[&lt;/span>--sourcedir &amp;lt;dir&amp;gt;&lt;span style="color:#ff79c6">][&lt;/span>--targetdir &amp;lt;dir&amp;gt;&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>build&lt;/code> command will ensure that the directory that you are attempting to package will produce a valid Puppet Content Template by looking for a &lt;code>pct-config.yml&lt;/code> and a &lt;code>content&lt;/code> directory.&lt;/p>
&lt;p>The resulting &lt;code>tar.gz&lt;/code> package will be created by default in &lt;code>$cwd/pkg&lt;/code>. You can change the directory the package is created in by providing &lt;code>--targetdir&lt;/code>.&lt;/p>
&lt;h3 id="installing-template-packages">Installing template packages&lt;/h3>
&lt;p>Packages created using the &lt;code>build&lt;/code> command can be installed by extracting the &lt;code>tar.gz&lt;/code> into the &lt;strong>Default Template Location&lt;/strong>.&lt;/p>
&lt;h4 id="local-archive">Local archive&lt;/h4>
&lt;p>Packages created using the &lt;code>build&lt;/code> command can also be installed with the &lt;code>pct install&lt;/code> command.&lt;/p>
&lt;p>For example, this command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pct install ~/my-template-1.2.3.tar.gz
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Will install the template contained in &lt;code>my-template-1.2.3.tar.gz&lt;/code> to the default template location.&lt;/p>
&lt;h4 id="remote-archive">Remote archive&lt;/h4>
&lt;p>Packages created using the &lt;code>build&lt;/code> command can be automatically downloaded and extracted with &lt;code>pct install&lt;/code> so long as you know the URL to where the archive is.&lt;/p>
&lt;p>For example, this command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pct install https://packages.mycompany.com/pct/my-template-1.2.3.tar.gz
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Will attempt to download the PCT template from the specified url and then afterward install it like any other locally available PCT template archive.&lt;/p>
&lt;h4 id="remote-git-repository">Remote Git Repository&lt;/h4>
&lt;p>&lt;strong>Git&lt;/strong> must be installed for this feature to work. The git repository must contain only one template and must be structured with the &lt;code>pct-config.yml&lt;/code> file and the &lt;code>content&lt;/code> directory in the root directory of the repository.&lt;/p>
&lt;p>For more information on template structures see the &lt;a href="https://github.com/puppetlabs/pct#writing-templates">Writing Templates&lt;/a> section in the &lt;code>README&lt;/code>.&lt;/p>
&lt;p>For example, this command:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">pct install --git-uri https://github.com/myorg/myawesometemplate
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will attempt to clone the PCT template from the git repository at the specified URI and install to the default template location.&lt;/p></description></item><item><title>Docs: Sharing Tools</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/usage/tool-sharing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/prm/usage/tool-sharing/</guid><description>
&lt;p>After you&amp;rsquo;ve written your own tool you may wish to share it with other members of your team or the wider Puppet community. Work is underway to improve this initial functionality.&lt;/p>
&lt;h3 id="prm-build">prm build&lt;/h3>
&lt;p>This command will attempt to package the current working directory. You can change the directory to pack by providing &lt;code>--sourcedir&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">prm build &lt;span style="color:#ff79c6">[&lt;/span>--sourcedir &amp;lt;dir&amp;gt;&lt;span style="color:#ff79c6">][&lt;/span>--targetdir &amp;lt;dir&amp;gt;&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>build&lt;/code> command will ensure that the directory that you are attempting to package will produce a valid Puppet Runtime Manager tool by looking for a &lt;code>prm-config.yml&lt;/code> and a &lt;code>content&lt;/code> directory.&lt;/p>
&lt;p>The resulting &lt;code>tar.gz&lt;/code> package will be created by default in &lt;code>$cwd/pkg&lt;/code>. You can change the directory the package is created in by providing &lt;code>--targetdir&lt;/code>.&lt;/p>
&lt;blockquote>
&lt;p>NOTE: When using &lt;code>--sourcedir&lt;/code> use either the full path or the relative path without the leading &lt;code>./&lt;/code> (&lt;code>.\&lt;/code> on Windows).
If you use the leading &lt;code>./&lt;/code> it will incorrectly tar the project.&lt;/p>
&lt;/blockquote></description></item><item><title>Docs: Tools</title><link>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/tools-included-in-litmus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://puppetlabs.github.io/content-and-tooling-team/docs/litmus/usage/tools-included-in-litmus/</guid><description>
&lt;p>Litmus wraps functionality from other tools, providing a rake interface for you to develop modules.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/puppetlabs/bolt">Bolt&lt;/a> is an open source orchestration tool that automates the manual work it takes to maintain your infrastructure. Litmus is built on top of bolt, so it natively handles SSH, WinRM and Docker. The inventory file specifies the protocol to use for each target, when using litmus this can be found in &lt;code>spec/fixtures/litmus_inventory.yaml&lt;/code>, along with connection specific information. Litmus uses Bolt to execute module tasks.&lt;/li>
&lt;li>&lt;a href="https://serverspec.org/">Serverspec&lt;/a> lets you check your servers are configured correctly.&lt;/li>
&lt;li>Puppet Development Kit (PDK) provides a complete module structure, templates for classes, defined types, and tasks, and a testing infrastructure.&lt;/li>
&lt;li>&lt;a href="https://github.com/puppetlabs/litmus_image">Litmus Image&lt;/a> is a group of Docker build files. They are specifically designed to set up systemd/upstart on various nix images. This is a prerequisite for testing services with Puppet in Docker images.&lt;code>litmus_image&lt;/code> generates an inventory file, that contains connection information for each system instance. This is used by subsequent commands or by rspec.&lt;/li>
&lt;/ul>
&lt;p>These tools are built into the Litmus commands:&lt;/p>
&lt;h4 id="provision">Provision&lt;/h4>
&lt;p>To provision systems we created a &lt;a href="https://github.com/puppetlabs/provision">module&lt;/a> that will provision containers / images / hardware in ABS (internal to Puppet) and Docker instances. Provision is extensible, so other provisioners can be added - please raise an &lt;a href="https://github.com/puppetlabs/provision/issues">issue&lt;/a> on the Provision repository, or create your own and submit a &lt;a href="https://github.com/puppetlabs/provision/pulls">PR&lt;/a>!&lt;/p>
&lt;p>rake task -&amp;gt; litmus -&amp;gt; bolt -&amp;gt; provision -&amp;gt; docker
-&amp;gt; vagrant
-&amp;gt; abs (internal)
-&amp;gt; vmpooler (internal)&lt;/p>
&lt;h4 id="installing-an-agents">Installing an agents&lt;/h4>
&lt;p>rake task -&amp;gt; bolt -&amp;gt; puppet_agent module&lt;/p>
&lt;h4 id="installing-modules">Installing modules&lt;/h4>
&lt;p>PDK builds the module tar file and is copied to the target using Bolt. On the target machine, run &lt;code>puppet module install&lt;/code>, specifying the tar file. This installs the dependencies listed in the metadata.json of the built module.&lt;/p>
&lt;p>rake task -&amp;gt; pdk -&amp;gt; bolt&lt;/p>
&lt;h4 id="running-tests">Running tests&lt;/h4>
&lt;p>rake task -&amp;gt; serverspec -&amp;gt; rspec&lt;/p>
&lt;h4 id="tearing-down-targets">Tearing down targets&lt;/h4>
&lt;p>rake task -&amp;gt; bolt provision -&amp;gt; docker
-&amp;gt; abs (internal)
-&amp;gt; vmpooler&lt;/p></description></item></channel></rss>